---
title: "Building Claims Rules"
format: 
  html:
    reference-location: block
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false
knitr::opts_chunk$set(
  dev        = "ragg_png",
  dpi        = 300,
  out.width  = "100%",
  fig.width  = 8,
  fig.asp    = 0.618,
  fig.retina = 2,
  fig.align  = "center",
  fig.show   = "hold")

options(scipen = 999)
library(here)
library(tidyverse)
library(janitor)
library(gt)
library(fuimus)

head_tail <- function(x, n = 5, by = NULL) {
  dplyr::bind_rows(
    dplyr::slice_head(x, n = n, by = dplyr::all_of(by)),
    dplyr::slice_tail(x, n = n, by = dplyr::all_of(by)))
}

count_unique <- \(df, 
                  ..., 
                  .rename_first = "value", 
                  .set_names, 
                  .names_to = "variable") {
  
  df <- fuimus::df_2_chr(df)
  df <- dplyr::select(df, ...) |> 
    names() |> 
    purrr::map(~ dplyr::count(df, .data[[.x]], sort = TRUE)) |> 
    purrr::set_names(nm = .set_names)
  
  first_column_rename <- \(x, first = .rename_first) {
    for (i in 1:length(x)) {
      colnames(x[[i]])[1] <- first
      }
    x
  }
  
  first_column_rename(df) |> 
    purrr::list_rbind(names_to = .names_to)
}

rules <- read_csv(
  here("posts/rules/data/rules_raw.csv"),
  col_types = cols(
  row       = col_integer(),
  id_rule   = col_integer(),
  id_name   = col_character(),
  id_order  = col_integer(),
  category  = col_factor(),
  alert     = col_character(),
  var       = col_character(),
  action    = col_character(),
  value     = col_character(),
  rule      = col_character(),
  x9        = col_character(),
  x10       = col_character())) |> 
  mutate(
    category = remove_quotes(as.character(category)),
    category = str_remove_all(category, "\\r|\\n"),
    alert = remove_quotes(alert),
    alert = str_remove_all(alert, "\\r|\\n"),
    rule = remove_quotes(rule),
    rule = str_remove_all(rule, "\\r|\\n")) |> 
  fill(rule) |> 
  select(
    row,
    id = id_rule,
    step = id_order,
    name = id_name,
    variable = var,
    action,
    value,
    category,
    description = rule,
    rationale  = alert
  )

rules[1, 9, drop = TRUE] <- "CPT Code is [43760] AND Encounter Date of Service after [01/01/2019]"
rules[2, 9, drop = TRUE] <- "CPT Code is [43760] AND Encounter Date of Service after [01/01/2019]"
```


# Anatomy of a Rule

   - Rule Descriptors
      - `id`: Unique Numeric Identifier; `<Primary Key>`
      - `name`: Unique Alphanumeric Identifier; `<Primary Key>`
      - `category`: High-Level Classification
      - `description`: Human Readable Description of Rule Steps
      - `rationale`: Reason for Implementation
      - `sources`: URLs, References, or Documentation
  - Step Components
      - `step`: Indicates Order of Step in Rule Validation
      - `variable`: Variable to Evaluate
      - `class`: Variable Data Class
      - `action`: Operation Performed to Test for Expected State
      - `method`: Operation Performed to Test for Expected State
      - `expression`: Actual Code to Run
      - `value`: Value Representing Expected State of Rule Variable


```{r}
rules[1, 2:10] |> glimpse()
rules[2, 2:10] |> glimpse()
```


```{r}
library(S7)

rule <- S7::new_class(
  "crule",
  properties = list(
    id = S7::class_integer,
    name = S7::class_character,
    category = S7::class_character,
    definition = S7::class_character,
    rationale = S7::class_character,
    expression = S7::class_expression,
    steps = S7::class_integer
    ),
  package = "cruler"
  )

rule_01 <- rule(
  id = 1L,
  name = "HCPCS:EX:01",
  category = "Invalid HCPCS",
  definition = "<Date of Service> is [2019-01-01] or after |AND| <HCPCS Code> is [43760]",
  rationale = "Effective 2019-01-01, HCPCS 43760 is invalid; See 43762 - 43763",
  expression = expression(dos >= as.Date("2019-01-01") && hcpcs == 43760),
  steps = 2L
  )

rule_01
```


```{r}
rules[3, 2:10] |> glimpse()

rules[4, 2:10] |> glimpse()

rules[5, 2:10] |> glimpse()

rules[6, 2:10] |> glimpse()
```

## Descriptors

-   [X] `id`
-   [X] `name`: Split letters/numbers, categorize Payer, State, etc.
-   [X] `category`: 
-   [ ] `description`:
-   [ ] `rationale`: Steps are detailed in the rationale that are missing from the ruleset
-   [X] `sources`: Extract urls from `category`

```{r}
#| label: descriptors
#| echo: true
#| message: false
#| warning: false
descriptors <- rules |> 
  select(id, name, category, description, rationale) |> 
  distinct() |> 
  mutate(sources = str_extract_all(category,"https?://[^\\s]+"),
         category = str_remove_all(category,"https?://[^\\s]+")) |>
  unnest(sources, keep_empty = TRUE) |>
  separate_longer_delim(sources, delim = "https:") |>
  mutate(sources = na_if(sources, "") |> str_squish(),
         sources = if_else(!is.na(sources), str_c("https:", sources), sources),
         category = na_if(category, "") |> str_squish(),
         description = str_squish(description),
         description = str_remove_all(description, "►"),
         description = gsub(",(?!\\s)", ", ", description, perl = TRUE) |> str_squish(),
         rationale = str_squish(rationale),
         rationale = str_remove_all(rationale, "►"),
         rationale = gsub(",(?!\\s)", ", ", rationale, perl = TRUE) |> str_squish()
         ) |> 
  nest(sources = c(sources))

descriptors
```

### Name

```{r}

# FIX
"VFC-GA"
"BCBSMI"

payers <- c("BCBS", "MCD", "VFC-")

other <- c(
  "INTEG",
  "LABS",
  "NEURO",
  "ORTHO",
  "MEDSV",
  "VACCN",
  "COVID19-",
  "E&M",
  "UNVSL",
  "ICD10-",
  "RHC",
  "ANEST",
  "SURG",
  "FQHC",
  "TELEH",
  "ASC",
  "DIGES",
  "RADIO",
  "PRVNT",
  "OPTHL",
  "FOOT",
  "FERTL",
  "DME",
  "AUDIO",
  "OBGYN")
```


```{r}
#| label: name
#| echo: true
#| message: false
#| warning: false
descriptors |> 
  reframe(
    id,
    name,
    state = if_else(
      str_sub(name, 1, 2) %in% state.abb, 
      str_sub(name, 1, 2), NA_character_),
    payer = strex::str_extract_non_numerics(str_sub(name, 3, -1)),
    n = strex::str_extract_numbers(name)
  ) |> 
  unnest(c(n, payer), keep_empty = TRUE) |> 
  mutate(
    state = if_else(
      str_sub(payer, -2) %in% state.abb, 
      str_sub(payer, -2), state)
  ) |> 
  # filter(!is.na(state)) |> 
  slice(701:1380) |> 
  print(n = 700)
```

### Sample

```{r}
#| label: category
#| echo: true
#| message: false
#| warning: false
descriptors |>
  slice_sample(n = 15) |> 
  mutate(category = str_wrap(category, width = 50),
         description = str_wrap(description, width = 60),
         rationale = str_wrap(rationale, width = 50)) |>
  select(-sources) |> 
  gt(rowname_col = "name",
     groupname_col = "category",
     row_group_as_column = TRUE) |>
  cols_align(align = "left", columns = -c(id)) |>
  cols_align(align = "center", columns = c(id)) |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = "left",
        weight = "bold",
        size = px(14),
        whitespace = "break-spaces",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(description))) |>
  tab_style(
      style = cell_text(
        color = "#0B0B35",
        align = "center",
        weight = "bold",
        size = px(16),
        font = google_font(name = "Roboto Condensed")),
      locations = cells_body(columns = c(id))) |>
  gtExtras::gt_add_divider(
    columns = "description", 
    style = "solid",
    weight = "3px",
    color = "royalblue") |>
  tab_style(
    style = cell_text(
      v_align = "middle", 
      align = "right",
      weight = "800"),
    locations = cells_row_groups()) |> 
  tab_style(
    style = cell_text(
      size = px(16),
      font = google_font(name = "JetBrains Mono"),
      v_align = "middle", 
      align = "center"
      ),
    locations = cells_stub()) |> 
  opt_stylize(add_row_striping = TRUE) |>
  tab_options(table.width = pct(85),
              quarto.disable_processing = TRUE)
```


## Components

-   [ ] `step`: 
-   [X] `variable`: Recode to standardize
-   [ ] `class`: Variable Data Class
-   [ ] `group`: Variable Grouping
-   [ ] `action`: Remove
-   [ ] `method`: Operation Performed to Test for Expected State
-   [ ] `expression`: Actual Code to Run
-   [ ] `value`: Coerce to correct data type, deal with wildcards

```{r}
#| label: components
#| echo: true
#| message: false
#| warning: false
components <- rules |> 
  select(id, step, variable, action, value) |> 
  distinct()

components
```


### Variable

   - `hcpcs`: 
   - `mod_1`: 
   - `mod_2`:
   - `mod_3`:
   - `mod_4`:
   - `unit`: 
   - `icd`:
   - `dos`:
   - `pos`:
   - `ub04`:
   - `ndc`:
   - `rev_code`:
   - `cci`:
   - `lcd`:
   - `ncd`:
   - `dob`:
   - `sex`:
   - `rendering`:
   - `referring`:
   - `primary_class`:
   - `primary_name`:
   - `primary_auth`:
   - `secondary_class`:
   - `secondary_name`:

```{r}
#| label: variable
#| echo: true
#| message: false
#| warning: false
components <- components |>
  mutate(variable = case_match(variable,
      c("CPT CODE", 
        "CPT Code", 
        "CPT code", 
        "CPT", 
        "Code Check Expired CPT Alert (Presence)", 
        "CPT is one of") ~ "hcpcs",
      c("Mod1", 
        "CPT Mod1", 
        "CPT Mod 1", 
        "CPTMod1", 
        "Code Check CPT Mod Alert (Presence)", 
        "CPT MOD1", 
        "CPT Mod1 (Presence)") ~ "mod_1",
      c("Mod2", 
        "CPT MOD2", 
        "CPT Mod 2", 
        "CPT Mod2 (Presence)", 
        "CPTMod2", 
        "CPT Mod2") ~ "mod_2",
      "CPT Mod3" ~ "mod_3",
      "CPT Mod4" ~ "mod_4",
      "CPT Units" ~ "unit",
      c("Dx code", 
        "DX Code", 
        "Dx Code", 
        "Code Check Expired DX Alert (Presence)") ~ "icd",
      c("Encounter Date of Service", 
        "Date of Service") ~ "dos",
      c("Location", 
        "Place of Service") ~ "pos",
      c("CPT UB04", 
        "UB04 Bill Type") ~ "ub04",
      "CPT NDC (Presence)" ~ "ndc",
      "CPT Rev Code" ~ "rev_code",
      "Code Check CCI Alert (Presence)" ~ "cci",
      "Code Check LCD Alert (Presence)" ~ "lcd",
      "Code Check NCD Alert (Presence)" ~ "ncd",
      c("Patient Age", 
        "Code Check Age Alert (Presence)") ~ "dob",
      c("Patient Sex", 
        "Code Check Gender Alert (Presence)") ~ "sex",
      "NA" ~ NA_character_,
      "Rendering Provider" ~ "rendering",
      "Referring Provider (Presence)" ~ "referring",
      c("Primary Insurance Class", 
        "Primary Insurance class", 
        "Primary insurance class") ~ "primary_class",
      "Primary Insurance" ~ "primary_name",
      "Secondary Insurance Class" ~ "secondary_class",
      "Secondary Insurance" ~ "secondary_name",
      c("Primary Insurance Authorization (Presence)", 
        "Primary Insurance Authorization (Presence) is not [Present]") ~ "primary_auth",
      .default = variable) |> 
      as_factor())

components
```

### Class & Group

```{r}
#| label: class_group
#| echo: true
#| message: false
#| warning: false
components <- components |> 
  mutate(
    class = case_match(variable,
      c("sex", "rendering", "referring", 
        "primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name", "ncd", "lcd", 
        "cci", "ndc", "ub04", "pos", 
        "icd", "hcpcs", "mod_1", "mod_2", 
        "mod_3", "mod_4") ~ "<chr>",
      c("rev_code", "unit") ~ "<int>",
      c("dos", "dob") ~ "<date>"
    ) |> as_factor(),
    group = case_match(as.character(variable),
      c("sex", "dos", "dob") ~ "patient",
      c("rendering", "referring") ~ "provider",
      c("hcpcs", "mod_1", "mod_2", "mod_3", "mod_4", 
        "rev_code", "unit", "ndc", "pos") ~ "procedure",
      c("icd") ~ "diagnosis",
      c("ub04", "1500") ~ "claim",
      c("ncd", "lcd", "cci") ~ "ncci",
      c("primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name") ~ "payer"
    ) |> as_factor())

components # |> 
  # select(class, group, variable, action) |> 
  # arrange(class, group, variable) |>
  # gt() |>
  # cols_align(align = "left") |>
  # opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  # opt_all_caps() |>
  # tab_style(
  #     style = cell_text(
  #       align = 'left',
  #       weight = "bold",
  #       font = google_font(name = "Roboto Mono")),
  #     locations = cells_body(columns = c(action))) |>
  # tab_style(
  #     style = cell_text(
  #       align = 'left',
  #       weight = "normal",
  #       style = "italic",
  #       decorate = "underline",
  #       stretch = "condensed",
  #       font = google_font(name = "Fira Code")),
  #     locations = cells_body(columns = c(class))) |>
  # tab_options(table.width = pct(100),
  #             quarto.disable_processing = TRUE)
```

#### Date of Service

```{r}
components |> 
  filter(variable == "dos") |> 
  mutate(class = "<date>",
         value = anytime::anydate(value),
         method = if_else(str_detect(action, "after"), ">", "<")) |> 
  select(id, step, class, variable, method, value) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  opt_stylize() |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### Patient Age

All ages should be in the same unit of time, in this case, days.

Should be calculated from the encounter's Date of Service (`dos`) and the patient's Date of Birth (`dob`).

```{r}
components |> 
  filter(variable == "dob") |> 
  mutate(variable = "age",
         class = "<int>", 
         age = strex::str_extract_numbers(value),
         period = strex::str_extract_non_numerics(value),
         .before = variable) |> 
  unnest(c(age, period)) |> 
  mutate(
    age = as.integer(age),
    period = str_remove_all(period, "\\s|,"),
    value = NULL,
    method = case_match(
      action,
      c("is younger than", "younger than") ~ "<",
      "is older than" ~ ">",
      "is" ~ "==",
      .default = NA_character_),
    days = case_when(
      period == "years" ~ as.duration(years(age)) / ddays(1),
      period == "months" ~ as.duration(months(age)) / ddays(1),
      period == "days" ~ as.duration(days(age)) / ddays(1),
      .default = NA_real_),
    dos = lubridate::today(),
  ) |> 
  select(id, step, class, variable, method, age, period, days) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  fmt_integer(columns = c("age", "days")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### Unit (HCPCS)

```{r}
components |> 
  filter(variable == "unit") |> 
  mutate(class = "<int>", 
         value = as.integer(value),
         method = if_else(str_detect(action, "is not"), "!=", "=="),
         .before = variable) |> 
  select(id, step, class, variable, method, value, action) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### NDC

How can this be represented in relational algebra? Detect presence with regex?

If not present, then is `NA` its' representation? If so, `is.na(x)` would equal `is not present` and `!is.na(x)` would equal `is present`


```{r}
components |> 
  filter(variable == "ndc") |> 
  mutate(class = "<lgl>", 
         .before = variable, 
         method = if_else(str_detect(action, "is not"), "is.na(x)", "!is.na(x)")) |> 
  select(id, step, class, variable, method, value, action) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### ICD

   * has all
   * is
   * is not
   * is one of

some values contain wildcards *

```{r}
components |> 
  filter(variable == "icd") |>
  mutate(wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         nchar = if_else(wc == 1, str_count(value, "[[:alnum:]]"), 0L),
         class = "<chr>",
         method = case_when(
           action == "is" & wc == 1 ~ "%in%",
           action == "is" & wc == 0 ~ "==",
           .default = NA_character_)
         ) |> 
  filter(!is.na(method)) |> 
  select(id, step, class, variable, method, value, action, wc, nchar) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

## Unevaluated Code

```{r}
#| label: vars
#| echo: true
#| eval: false
#| message: false
#| warning: false

categorize_vars |>
  separate_longer_delim(cols = value, delim = ",") |>
  mutate(value = str_squish(value),
         neg = case_when(str_detect(action, "not") ~ 1L, .default = 0L),
         wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         .after = value)

head_tail(rules_new, n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action, value))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)

rules_new |>
  filter(!is.na(var)) |>
  group_by(var) |>
  count(action) |>
  ungroup() |>
  arrange(var, desc(n), action) |>
  gt(groupname_col = "var", row_group_as_column = TRUE) |>
  cols_align(align = "left") |>
  opt_table_font(
    font = google_font(name = "Roboto Condensed"),
    weight = "bold"
    ) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```


## Regexes

```{r}
#| label: regex
#| eval: false
#| echo: true
#| message: false
#| warning: false

rules_new |>
  filter(wc == 1,
         var == "hcpcs") |>
  mutate(value = str_remove_all(value, "\\*"),
         chars = 5 - str_length(value),
         .after = value) |>
  mutate(
    regex = case_when(
      chars == 0 ~ glue_chr("^<<value>>$", .open = "<<", .close = ">>"),
      chars == 1 ~ glue_chr("^<<value>>[0-9]$", .open = "<<", .close = ">>"),
      chars > 1 ~ glue_chr("^<<value>>[0-9]{<<chars>>}$", .open = "<<", .close = ">>")),
    regex = case_when(neg == 1L ~ glue_chr('!{regex}'), .default = regex),
    .after = regex
  ) |>
  head_tail(n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(regex))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```


```{r}
#| label: misc
#| eval: false
#| echo: true
#| message: false
#| warning: false
northstar::search_descriptions(hcpcs_desc_type = "Long") |> 
  # dplyr::mutate(not_hcpcs = !grepl("^99[0-9]{3}$", hcpcs_code)) |> 
  filter(!grepl("^99[0-9]{3,3}$", hcpcs_code)) |>
  # dplyr::mutate(has_hcpcs = grepl("^J[0-9]{4}$", hcpcs_code)) |> 
  filter(str_detect(hcpcs_code, regex("^J[0-9]{4}$"))) |> 
  filter(str_detect(hcpcs_code, regex("^(?!5405)(?<![0-9]{1})$"))) |> 
  print(n = 200)

# Match strings that don't start with "99" and don't end with 3 digits
pattern <- "^(?!99).*(?<![0-9]{3})$"

# Negation pattern
"^(?!9938[0-9]{1}$)"

# Begins with 0, ends with digit
"^0.*\\d$"

# Begins with 0, ends with letter
"^0.*[A-Z]$"

# Match strings that don't start with "a" and don't end with "z"
pattern <- "^(?!a).*[^z]$"
grep(pattern, c("apple", "banana", "cherry"), value = TRUE)
# Output: "banana" "cherry"

stringr::str_detect("99202", stringr::regex("^[992]{3}.*"))

grep("^[992]{3}.*", "99202", value = TRUE, invert = TRUE)


pattern = dplyr::case_when(
  chars == 0 & negation == FALSE ~ glue::glue("^<value>$", .open = "<", .close = ">"),
  chars > 0  & negation == FALSE ~ glue::glue("^<value>[0-9]{<chars>}$", .open = "<", .close = ">"),
  chars == 0 & negation == TRUE ~ glue::glue("^(?!<value>)$", .open = "<", .close = ">"),
  chars > 0  & negation == TRUE ~ glue::glue("^(?!<<value>>)(?<![0-9]{<<chars>>})$", .open = "<<", .close = ">>")
  )
```
