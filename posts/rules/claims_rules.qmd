---
title: "Building Claims Rules"
format: 
  html:
    reference-location: block
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false
knitr::opts_chunk$set(
  dev        = "ragg_png",
  dpi        = 300,
  out.width  = "100%",
  fig.width  = 8,
  fig.asp    = 0.618,
  fig.retina = 2,
  fig.align  = "center",
  fig.show   = "hold")

options(scipen = 999)
library(here)
library(gt)
library(S7)

source(here("posts/rules/scripts", "load.R"))
source(here("posts/rules/scripts", "functions.R"))
```


# Anatomy of a Rule

   - `rule` class
      - `identifier`: Unique Alphanumeric Identifier; `<Primary Key>`
      - `category`: High-Level Classification
      - `definition`: Human Readable Description of Rule Steps
      - `rationale`: Reason for Implementation
      - `source`: URLs, References, or Documentation
      - `steps`: List of Steps to Evaluate
  
  - `step` class
      - `type`: `qualifier` or `terminator`
         - `qualifier`s: identifies records that meet the evaluation criteria; record is skipped if criteria is not met
         - `terminator`: result indicates a pass or fail
      - `order`: Validation step order. Certain steps must be ahead of others, e.g. `dos` should always be first
      - `variable`: element of claim to evaluate
      - `value`: valid variable instance, expected state evaluated against it
      - `condition`: functional code to call based on method selected
      - `alert`: message to display if `terminator` condition is not met 
      - `method`: could define different methods for a single variable
          - regex: for matching patterns of long lists of HCPCS codes
          - calculation: days elapsed between date of birth and date of service
          - comparison: check if a value is greater than or less than another value
          - equality: check if a value is equal to another value
          - presence: check if a value is present

      
  - `variable` classes:
     - Insurance `type`: Primary, Secondary, Tertiary
        - Insurance `class`: Self-Pay, Commercial, Medicare, Medicaid, etc.
           - Insurance `payer`
             - `name`: BCBS, Medicaid, etc.
             - `state`: State Abbreviation (optional)
     - Date of Service (`dos`)
     - ICD-10 Code (`icd`)
     - Provider (`provider`)
       - `role`: Rendering, Referring
       - `credential`: MD, DO, etc.
     - Procedure (`hcpcs`)
       - `code`: HCPCS Code
       - `mod_1`: Modifier 1
       - `mod_2`: Modifier 2
       - `mod_3`: Modifier 3
       - `mod_4`: Modifier 4
       - `unit`: Number of Units
     - NDC Code (`ndc`)
     - Revenue Code (`rev_code`)
     - Place of Service (`pos`)
        - `code`: 02, 11, etc.
        - `type`: Facility, Non-Facility
        - `description`: Hospital, Clinic, etc.
     - Patient:
        - Age (`age`)
        - Sex (`sex`)
     - Claim
        - type: Institutional (`ub04`), Professional (`1500`)
     

## S7 Class

```{r}
#| label: s7_class
#| echo: false
#| eval: false
#| message: false
#| warning: false

element <- S7::new_class(
  name = "element",
  package = "crule",
  properties = list(
    label = S7::new_property(
      class = S7::class_character, 
      default = c("dos", "hcpcs", "pos", "icd", "payer", "provider", "patient"),
      setter = function(self, value) {
        self@label = match.arg(value, c("dos", "hcpcs", "pos", "icd", "payer", "provider", "patient"))
        self
      }),
    attributes = S7::new_property(
      class = S7::class_list
      )
  )
)

element

payer <- element(
  label = "payer",
  attributes = list(
    name = S7::new_property(
      class = S7::class_character, 
      default = c("BCBS", "UHC", "Medicaid", "Medicare", "Aetna", "Cigna"),
      setter = function(self, value) {
        self@name = match.arg(value, c("BCBS", "UHC", "Medicaid", "Medicare", "Aetna", "Cigna"))
        self
      }),
    type = S7::new_property(
      class = S7::class_character, 
      default = c("Primary", "Secondary", "Tertiary"),
      setter = function(self, value) {
        self@type = match.arg(value, c("Primary", "Secondary", "Tertiary"))
        self
      }),
    classification = S7::new_property(
      class = S7::class_character, 
      default = c("Commercial", "Self-Pay", "Medicare", "Medicaid"),
      setter = function(self, value) {
        self@classification = match.arg(value, c("Commercial", "Self-Pay", "Medicare", "Medicaid"))
        self
      }),
    state = S7::new_property(
      class = S7::class_character, 
      default = c(state.abb, state.name),
      setter = function(self, value) {
        self@state = match.arg(value, c(state.abb, state.name))
        self
      })
    )
  )

payer@attributes$name

payer()

step <- S7::new_class(
  name = "step",
  package = "crule",
  properties = list(
    order = S7::class_integer,
    element = element,
    value = S7::new_property(class = S7::class_any)
    ),
  validator = function(self) {
    if (length(self@order) != 1)    {"@order must be length 1"}
    if (length(self@variable) != 1) {"@variable must be length 1"}
  })

rule <- S7::new_class(
  name = "rule",
  package = "crule",
  properties = list(
    index = S7::class_integer,
    identifier = S7::class_character,
    category = S7::class_character,
    definition = S7::class_character,
    rationale = S7::class_character,
    alert = S7::class_character,
    timestamp = S7::new_property(class = S7::class_Date, default = Sys.Date()),
    steps = step
    )
  )

step

step()

rule

rule()


hcpcs_exp <- rule(
  index = 1L,
  identifier = "HCPCS:EXP:001",
  category = "Invalid HCPCS",
  definition = "<DOS> is after [2019-01-01] AND <HCPCS> is [43760]",
  rationale = "Effective 2019-01-01, HCPCS 43760 is invalid",
  alert = "See HCPCS [43762, 43763]",
  steps = c(
    dos = step(order = 1L,
               variable = "dos",
               value = as.Date(c("2019-01-01", "2019-01-01"))),
    hcpcs = step(order = 2L,
                 variable = "hcpcs",
                 value = c("43760"))
    )
  )

hcpcs_exp



dos_var <- step(
  order = 1L,
  variable = "dos",
  value = "2019-01-01"
)

dos_var@condition("2020-01-01")
```

## Cleaning Definitions

```{r}
#| label: dirty_definition
#| echo: true
#| eval: true
#| message: false
#| warning: false
dirty_definition <- clean_combine |> 
  select(number, definition) |> 
  distinct(number, .keep_all = TRUE) |> 
  mutate(definition = str_remove_all(definition, regex("\\s*\\(\\s*\\d*\\s*\\)\\s*")),
         definition = str_remove_all(definition, regex("\\(Presence\\)\\s*")),
         nest1 = str_extract_all(definition, regex("\\(\\s.*?\\s\\)")),
         nest2 = str_extract_all(definition, regex("\\(\\(.*\\)\\)")),
         definition = str_replace_all(definition, regex("\\(\\s.*?\\s\\)"), "<<NESTED>>"),
         definition = str_replace_all(definition, regex("\\(\\(.*\\)\\)"), "<<NESTED>>")) |> 
  unnest(c(nest1, nest2), keep_empty = TRUE)

dirty_definition
```

### Nested Statements

```{r}
#| label: clean_nested
#| echo: true
#| eval: true
#| message: false
#| warning: false
clean_nested <- dirty_definition |>
  select(number, nest1, nest2) |> 
  pivot_longer(
    cols = c(nest1, nest2),
    names_to = "variable",
    values_to = "nested") |>
  filter(!is.na(nested)) |>
  select(number, nested) |>
  mutate(nested = str_remove_all(nested, regex("\\(\\s*|\\s*\\)|\\((|\\))")),
         nested = str_replace_all(nested, "HOMEAND", "HOME] AND"),
         nested = str_replace_all(nested, "CPT", "@hcpcs"),
         nested = str_replace_all(nested, "DX", "@icd"),
         nested = str_remove_all(nested, "Code "),
         nested = str_replace_all(nested, "@hcpcs Mod", "@mod_"),
         nested = str_replace_all(nested, "@hcpcs Rev", "@rev"),
         nested = str_replace_all(nested, "Place of [Ss]ervice", "@pos"),
         nested = str_replace_all(nested, "Patient Age", "@age"),
         nested = str_replace_all(nested, "@hcpcs Units", "@unit"),
         nested = str_replace_all(nested, "Location", "@location"),
         nested = str_replace_all(nested, "Primary Insurance", "@primary_name"),
         nested = str_replace_all(nested, "Primary Insurance Class", "@primary_class"),
         nested = str_replace_all(nested, "Secondary Insurance", "@secondary_name"),
         nested = str_replace_all(nested, "Secondary Insurance Class", "@secondary_class"),
         nested = str_replace_all(nested, "false", "FALSE"),
         nested = str_replace_all(nested, "true", "TRUE"),
         nested = str_replace_all(nested, ", months", " MONS"),
         nested = str_replace_all(nested, ", years", " YRS"),
         nested = str_replace_all(nested, ", days", " DAYS"),
         nested = str_replace_all(nested, "younger", "less"),
         nested = str_replace_all(nested, "older", "greater"),
         nested = str_replace_all(nested, " ]", "]"),
         nested = str_replace_all(nested, "is \\[[Nn]ot [Pp]resent\\]", "is not [PRESENT]"),
         nested = str_replace_all(nested, ";", ","),
         nested = case_when(
           str_detect(nested, "AND") ~ str_replace_all(nested, "AND", "%AND%"),
           str_detect(nested, "OR") ~ str_replace_all(nested, "OR", "%OR%"), .default = nested),
         nested = str_replace_all(
           nested, 
           "@mod_1 is not 95, GT, GQ OR @mod_1 is 95, GT, GQ %AND% @pos is notHome", 
           "@mod_1 is not [95, GT, GQ] %OR% (@mod_1 is [95, GT, GQ] %AND% @pos is not [HOME])"),
         nested = str_replace_all(
           nested, 
           "TELEHEALTH PROVIDED OTHER THAN PT HOME, TELEHEALTH PROVIDED IN PATIENT HOME%OR%", 
           "[TELEHEALTH PROVIDED OTHER THAN PT HOME, TELEHEALTH PROVIDED IN PATIENT HOME] %OR%"),
         nested = if_else(number == 618, "(@hcpcs is [913*] %AND% @hcpcs is not [90480]) %OR% (@hcpcs is [90480] %AND% @hcpcs is not [913*])", nested),
         nested = if_else(number == 314, "(@pos is one of [02, 10] %AND% @mod_1 is not [95, GT, GQ]) %OR% (@mod_1 is [95, GT, GQ] %AND% @pos is not [12])", nested),
         nested = if_else(number == 210, "(@hcpcs is not [9200*, 92012, 92014]) %OR% (@hcpcs is one of [0*, 1*, 2*, 3*, 4*, 5*, 6*, 7*, 8*, 90*, 91*, 92015, 92018, 92019, 9202*, 9206*, 9207*, 9208*, 921*, 922*, 923*, 924*, 925*, 926*, 927*, 928*, 929*, 93*, 94*, 95*, 96*, 97*, 98*, A*, B*, C*, E*, G*, H*, J*, K*, L*, M*, P*, Q*, R*] %AND% @hcpcs is not [99*])", nested)
         ) |> 
  pos_name_to_code(nested) |> 
  mutate(.id = row_number(), 
         .by = number, 
         .after = number) |> 
  pivot_wider(
    names_from = .id,
    values_from = nested) |>
  janitor::clean_names() |>
  mutate(
    x1 = if_else(!is.na(x1), glue_chr("<<{x1}>>"), x1),
    x2 = if_else(!is.na(x2), glue_chr("<<{x2}>>"), x2),
    x3 = if_else(!is.na(x3), glue_chr("<<{x3}>>"), x3)
    ) |> 
  combine(name = x1, columns = c('x1', 'x2'), sep = " %AND% ") |>
  combine(name = x1, columns = c('x1', 'x3'), sep = " %AND% ")
```


```{r}
#| label: test_nested
#| echo: false
#| eval: false
#| message: false
#| warning: false
cat(c(
"@hcpcs@ is not [9200*, 92012, 92014] 
<OR> 
@hcpcs@ is one of ^[0-8A-CEGHJ-MP-R]|^[9][0134-8]|^[9][2][1-9]|^[9][2][0][26-8]|^[9][2][0][1][589]
<AND>
@hcpcs@ is not ^[^9][^9][0-9]"
))

uniq_nona <- \(x) collapse::funique(collapse::na_rm(x))

x <- c(
  "0", 
  "1", 
  "2", 
  "3", 
  "4", 
  "5", 
  "6", 
  "7", 
  "8", 
  "A", 
  "B", 
  "C", 
  "E", 
  "G", 
  "H", 
  "J", 
  "K", 
  "L", 
  "M", 
  "P", 
  "Q", 
  "R",
  "90", 
  "91", 
  "93", 
  "94", 
  "95", 
  "96", 
  "97", 
  "98", 
  "921", 
  "922", 
  "923", 
  "924", 
  "925", 
  "926", 
  "927", 
  "928", 
  "929", 
  "9202", 
  "9206", 
  "9207", 
  "9208", 
  "92015", 
  "92018", 
  "92019" 
  )

ln <- collapse::vlengths(x)

data.frame(
  x = x,
  ln = ln
) |> 
  group_by(ln) |> 
  nest() |> 
  collapse::rsplit(~ ln)


#   str_split_fixed("", n = 5) |>
#     as.data.frame() |>
#     purrr::map(na_if_common) |> 
#     purrr::map(uniq_nona)
# 
# "^[0-8A-CEGHJ-MP-R]|^[9][0134-8]|^[9][2][1-9]|^[9][2][0][26-8]|^[9][2][0][1][589]"
```



```{r}
#| label: clean_definition
#| echo: true
#| eval: true
#| message: false
#| warning: false
# 81 - @primary_name Authorization
clean_def <- dirty_definition |>
  select(number, definition) |> 
  distinct(number, .keep_all = TRUE) |> 
  mutate(definition = str_replace_all(definition, "CPT", "@hcpcs"),
         definition = str_replace_all(definition, "DX", "@icd"),
         definition =  str_remove_all(definition, "Code "),
         definition =  str_remove_all(definition, "\\s\\)"),
         definition =  str_remove_all(definition, fixed("GROUP")), # 197
         definition = str_replace_all(definition, "@hcpcs Mod", "@mod_"),
         definition = str_replace_all(definition, "@hcpcs Rev", "@rev"),
         definition = str_replace_all(definition, "@hcpcs NDC", "@ndc"),
         definition = str_replace_all(definition, "@hcpcs UB04", "@ub04"),
         definition = str_replace_all(definition, "Place of [Ss]ervice", "@pos"),
         definition = str_replace_all(definition, "Encounter Date of Service", "@dos"),
         definition = str_replace_all(definition, "Patient Age", "@age"),
         definition = str_replace_all(definition, "Patient Sex", "@sex"),
         definition = str_replace_all(definition, "@hcpcs Units", "@unit"),
         definition = str_replace_all(definition, "Location", "@location"),
         definition = str_replace_all(definition, "Referring Provider", "@referring"),
         definition = str_replace_all(definition, "Rendering Provider", "@rendering"),
         definition = str_replace_all(definition, "Primary Insurance Class", "@primary_class"),
         definition = str_replace_all(definition, "Secondary Insurance Class", "@secondary_class"),
         definition = str_replace_all(definition, "Primary Insurance", "@primary_name"),
         definition = str_replace_all(definition, "Secondary Insurance", "@secondary_name"),
         definition = str_replace_all(definition, "@primary_name Authorization", "@primary_auth"),
         definition = str_replace_all(definition, "false", "FALSE"),
         definition = str_replace_all(definition, "true", "TRUE"),
         definition = str_replace_all(definition, ", months", " MONS"),
         definition = str_replace_all(definition, ", years", " YRS"),
         definition = str_replace_all(definition, ", days", " DAYS"),
         definition = str_replace_all(definition, "younger", "less"),
         definition = str_replace_all(definition, "older", "greater"),
         definition = str_replace_all(definition, " ]", "]"),
         definition = str_replace_all(definition, "is \\[[Nn]ot [Pp]resent\\]", "is not [PRESENT]"),
         definition = str_replace_all(definition, "Present", "PRESENT"),
         definition = str_replace_all(definition, ";", ","),
         definition = str_replace_all(definition, "\\[Q4017, Q4018, Q4019, Q4020, L\\*", "[Q4017, Q4018, Q4019, Q4020, L*]"),
         definition = str_replace_all(definition, "\\[Q4021, Q4022, Q4023, Q4024, L\\*", "[Q4021, Q4022, Q4023, Q4024, L*]"),
         definition = str_replace_all(definition, "TELEHEALTH PROVIDED IN PATIENT HOMEAND", "TELEHEALTH PROVIDED IN PATIENT HOME] AND"),
         definition = str_replace_all(definition, "TELEHEALTH PROVIDED OTHER THAN IN PT HOME", "TELEHEALTH PROVIDED OTHER THAN IN PATIENT HOME"),
         definition = str_replace_all(definition, "TELEHEALTH PROVIDED OTHER THAN PT HOME", "\\[TELEHEALTH PROVIDED OTHER THAN IN PATIENT HOME"),
         definition = str_replace_all(definition, "INTERMEDIATE CARE FACILITY / MENTALLY RETARDED", "INTERMEDIATE CARE FACILITY/INDIVIDUALS WITH INTELLECTUAL DISABILITIES"),
         definition = str_replace_all(definition, "PSYCHIATRIC RESIDENTIAL TREATMENT FACILITY", "PSYCHIATRIC RESIDENTIAL TREATMENT CENTER"),
         definition = case_when(
           str_detect(definition, "AND") ~ str_replace_all(definition, "AND", "%AND%"),
           str_detect(definition, "OR") ~ str_replace_all(definition, "OR", "%OR%"), .default = definition),
         definition = if_else(number == 131, "@icd is [H72.00]", definition),
         definition = if_else(number == 127, "@icd has all [M17.11, M17.12]", definition),
         definition = if_else(number == 34, "@primary_class is [MEDICAID] %AND% @hcpcs is one of [1*, 2*, 3*, 4*, 5*, 6*] %AND% @mod_1 is not [AG]", definition)
         ) |> 
  pos_name_to_code(definition)
```


```{r}
clean_def |> 
  left_join(clean_nested, by = join_by(number)) |> 
  mutate(count = str_count(definition, fixed("<<NESTED>>"))) |> 
  filter(count > 1)
```



```{r}
# clean_combine |> 
#   pivot_longer(
#     cols = c(definition, nested),
#     names_to = "variable",
#     values_to = "definition") |>
#   filter(!is.na(definition)) |>
#   select(number, nested) |>
#   print(n = 200)
#   separate_longer_delim(cols = definition, delim = " ( ") |> 
#   separate_longer_delim(cols = definition, delim = " ) ") |> 
#   separate_longer_delim(cols = definition, delim = " AND ") |> 
#   mutate(parentheses = str_extract_all(definition, regex("\\s*\\(\\s*\\d+\\s*\\)\\s*")),
#     OR = str_detect(definition, fixed(" OR ")),
#          PARA = str_detect(definition, regex("\\(\\s|\\s\\)")),
#          definition = if_else(PARA, str_remove_all(definition, fixed(" )")), definition),
#          definition = if_else(PARA|OR, glue_chr("<<--{definition}-->>"), definition),
#          OR = NULL,
#          PARA = NULL,
#          definition = str_remove_all(definition, regex(r"{\(\d+\)}")),
#          definition = str_remove_all(definition, regex(r"{\(\D+\)}")),
#          definition = str_replace_all(definition, " ; ", ", "),
#          definition = str_replace_all(definition, ";", ", "),
#          definition = str_replace_all(definition, fixed(" ]"), "]"),
#          definition = str_replace_all(definition, " ] ", "]"),
#          definition = str_replace_all(definition, " , ", ", "),
#          definition = str_replace_all(definition, " ,", ", "),
#          definition = str_squish(definition)
#          ) |>
#   slice(1000:2000) |>
#   print(n = 100)
```


```{r}
#| label: qualify
#| echo: false
#| eval: false
#| message: true
#| warning: true
#| error: true
rule_001_example <- dplyr::tibble(
  dos = as.Date(c("2024-01-01", "2018-01-01")),
  hcpcs = as.character(c(43760, 99213))
)

rule_001_example

rule_001_example2 <- dplyr::tibble(
  dos = as.Date(c("2017-01-01", "2018-01-01", "2024-01-01")),
  hcpcs = as.character(c(99213, 99213, 99213))
)

rule_001_example2

qualify_dos <- function(df) {
  
  arg  <- rlang::caller_arg(df)
  call <- rlang::caller_env()
  
  x <- vctrs::vec_slice(df, df[["dos"]] >= as.Date("2019-01-01"))
  
  if (vctrs::vec_is_empty(x))  {
    cli::cli_abort(
      "No matches for {.strong dos} >= {.val {as.Date('2019-01-01')}} in {.arg {arg}}.", 
      arg = arg,
      call = call,
      class = "no_qualify_dos"
      )
  }
  return(x)
}

qualify_dos(rule_001_example)

qualify_dos(rule_001_example2)

qualify_hcpcs <- function(df) {
  
  arg  <- rlang::caller_arg(df)
  call <- rlang::caller_env()
  
  x <- vctrs::vec_slice(df, df[["hcpcs"]] == "43760")
  
  if (vctrs::vec_is_empty(x))  {
    cli::cli_abort(
      "No matches for {.strong hcpcs} == {.val {rlang::sym('43760')}} in {.arg {arg}}.", 
      arg = arg,
      call = call,
      class = "no_qualify_hcpcs"
      )
  }
  return(x)
}

qualify_hcpcs(rule_001_example)

qualify_hcpcs(rule_001_example2)

qualify_dos(rule_001_example) |> qualify_hcpcs()

qualify_dos(rule_001_example2) |> qualify_hcpcs()
```

## Metadata

   * Rulesets
      * Identifiers: 712
      * Categories: 621
      * Definitions: 703
      * Rationales: 659
      * Sources: 2

-   [X] `index`: Row number
-   [X] `number`: Rule Number
-   [X] `identifier`: Split letters/numbers, categorize Payer, State, etc.
-   [ ] `category`: Categories make little sense, need to be reclassified
-   [ ] `definition`: Define Variables, Logic, Remove Parentheses
-   [ ] `rationale`: Steps are detailed in the rationale that are missing from the ruleset
-   [X] `source`??: Extract urls from `category`

Need to define `instruction`/`suggestion` variable, taken from `rationale`


```{r}
#| label: descriptors
#| echo: false
#| eval: false
#| message: false
#| warning: false
descriptors |>
  gt() |> 
  gtExtras::gt_merge_stack(
    col1 = "category",
    col2 = "rationale",
    font_size = c("17px", "16px"),
    palette = c("darkgreen", "royalblue"),
    font_weight = c("bold", "normal"),
    small_cap = FALSE
  )
```

```{r}
#| label: sample
#| echo: false
#| eval: false
#| message: false
#| warning: false
descriptors |>
  slice_sample(n = 15) |> 
  mutate(
    category = str_wrap(category, width = 50),
    definition = str_replace_all(definition, " AND ", "<br><br><b>&&</b><br><br>") |>
      str_wrap(width = 60),
    definition = str_replace_all(definition, " OR ", "<br><br><b>||</b><br><br>") |>
      str_wrap(width = 60),
    definition = str_remove_all(definition, regex("\\s*\\(\\s*\\d+\\s*\\)\\s*")) |>
      str_wrap(width = 60),
    definition = str_squish(definition),
    rationale = str_wrap(rationale, width = 50)) |>
  select(-source, -index) |> 
  gt(rowname_col = "identifier",
     row_group_as_column = TRUE) |>
  fmt_markdown(columns = c("definition")) |>
  cols_align(align = "left", columns = -c(number)) |>
  cols_align(align = "center", columns = c(number)) |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = "left",
        weight = "bold",
        size = px(14),
        whitespace = "break-spaces",
        font = google_font(name = "JetBrains Mono")),
      locations = cells_body(columns = c(definition))) |>
  tab_style(
      style = cell_text(
        color = "#0B0B35",
        align = "center",
        weight = "bold",
        size = px(16),
        font = google_font(name = "Roboto Condensed")),
      locations = cells_body(columns = c(number))) |>
  sub_missing(missing_text = "NO CATEGORY") |>
  gtExtras::gt_add_divider(
    columns = "category", 
    style = "solid",
    weight = "3px",
    color = "royalblue") |>  
  gtExtras::gt_merge_stack(
    col1 = "category",
    col2 = "rationale",
    font_size = c("17px", "16px"),
    palette = c("darkgreen", "royalblue"),
    font_weight = c("bold", "normal"),
    small_cap = FALSE
  ) |> 
  tab_style(
    style = cell_text(
      v_align = "middle", 
      align = "right",
      weight = "800"),
    locations = cells_row_groups()) |> 
  tab_style(
    style = cell_text(
      size = px(16),
      font = google_font(name = "JetBrains Mono"),
      v_align = "middle", 
      align = "right"
      ),
    locations = cells_stub()) |> 
  opt_stylize(add_row_striping = TRUE) |>
  tab_options(table.width = pct(85),
              quarto.disable_processing = TRUE)
```

## Components of A Step

Two types of a step: `qualifier` and `terminator`

-   [X] `number`:
-   [X] `order`:
-   [X] `identifier`:
-   [X] `variable`: Recode to standardize names
-   [X] `class`: Variable Data Class
-   [X] `group`: Variable Grouping
-   [ ] `action`: _Remove_ Translate to `condition`
-   [ ] `value`: Coerce to correct data type, deal with wildcards
-   [ ] `condition`: Predicate function that evaluates to `TRUE` or `FALSE`

```{r}
#| label: components
#| echo: true
#| message: false
#| warning: false
components
```

### Variables

-   [X] `dos`: 81
-   [X] `age`: 158
-   [X] `unit`: 13
-   [X] `ub04`: 106
-   [X] `ndc`: 23
-   [X] `sex`: 3
-   [X] `pos`: 142
-   [X] `mod_1`, `mod_2`, `mod_3`, `mod_4`: 472
-   [X] `rev_code`: 19
-   [X] `referring`: 14
-   [X] `icd`: 251
-   [X] `hcpcs`: 1071
-   [X] `rendering`: 20
-   [X] `primary_class`: 371
-   [X] `primary_name`: 132
-   [X] `primary_auth`: 3
-   [X] `secondary_class`: 6
-   [X] `secondary_name`: 4

#### Cleaned

```{r}
#| label: cleaned_rules
#| echo: true
#| eval: true
#| message: false
#| warning: false
clean_combine
```





```{r}
#| label: vars
#| echo: false
#| eval: false
#| message: false
#| warning: false
categorize_vars |>
  separate_longer_delim(cols = value, delim = ",") |>
  mutate(value = str_squish(value),
         neg = case_when(str_detect(action, "not") ~ 1L, .default = 0L),
         wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         .after = value)

head_tail(rules_new, n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action, value))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)

rules_new |>
  filter(!is.na(var)) |>
  group_by(var) |>
  count(action) |>
  ungroup() |>
  arrange(var, desc(n), action) |>
  gt(groupname_col = "var", row_group_as_column = TRUE) |>
  cols_align(align = "left") |>
  opt_table_font(
    font = google_font(name = "Roboto Condensed"),
    weight = "bold"
    ) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

```{r}
#| label: regex
#| eval: false
#| echo: false
#| message: false
#| warning: false

c(
  "^[9][0][4][7][67]$"     = '9047(6|7)', 
  "^[9][0][56][1-9][0-9]$" = '905*|906*', 
  "^[9][0][7][1-5][02-9]$" = '907(1|2|3|4|5)',
  "^[9][1][3][01][0-9]$"   = '913'
  )

rules_new |>
  filter(wc == 1,
         var == "hcpcs") |>
  mutate(value = str_remove_all(value, "\\*"),
         chars = 5 - str_length(value),
         .after = value) |>
  mutate(
    regex = case_when(
      chars == 0 ~ glue_chr("^<<value>>$", .open = "<<", .close = ">>"),
      chars == 1 ~ glue_chr("^<<value>>[0-9]$", .open = "<<", .close = ">>"),
      chars > 1 ~ glue_chr("^<<value>>[0-9]{<<chars>>}$", .open = "<<", .close = ">>")),
    regex = case_when(neg == 1L ~ glue_chr('!{regex}'), .default = regex),
    .after = regex
  ) |>
  head_tail(n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(regex))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

```{r}
#| label: misc
#| eval: false
#| echo: false
#| message: false
#| warning: false
northstar::search_descriptions(hcpcs_desc_type = "Long") |> 
  # dplyr::mutate(not_hcpcs = !grepl("^99[0-9]{3}$", hcpcs_code)) |> 
  filter(!grepl("^99[0-9]{3,3}$", hcpcs_code)) |>
  # dplyr::mutate(has_hcpcs = grepl("^J[0-9]{4}$", hcpcs_code)) |> 
  filter(str_detect(hcpcs_code, regex("^J[0-9]{4}$"))) |> 
  filter(str_detect(hcpcs_code, regex("^(?!5405)(?<![0-9]{1})$"))) |> 
  print(n = 200)

# Match strings that don't start with "99" and don't end with 3 digits
pattern <- "^(?!99).*(?<![0-9]{3})$"

# Negation pattern
"^(?!9938[0-9]{1}$)"

# Begins with 0, ends with digit
"^0.*\\d$"

# Begins with 0, ends with letter
"^0.*[A-Z]$"

# Match strings that don't start with "a" and don't end with "z"
pattern <- "^(?!a).*[^z]$"
grep(pattern, c("apple", "banana", "cherry"), value = TRUE)
# Output: "banana" "cherry"

stringr::str_detect("99202", stringr::regex("^[992]{3}.*"))

grep("^[992]{3}.*", "99202", value = TRUE, invert = TRUE)


pattern = dplyr::case_when(
  chars == 0 & negation == FALSE ~ glue::glue("^<value>$", .open = "<", .close = ">"),
  chars > 0  & negation == FALSE ~ glue::glue("^<value>[0-9]{<chars>}$", .open = "<", .close = ">"),
  chars == 0 & negation == TRUE ~ glue::glue("^(?!<value>)$", .open = "<", .close = ">"),
  chars > 0  & negation == TRUE ~ glue::glue("^(?!<<value>>)(?<![0-9]{<<chars>>})$", .open = "<<", .close = ">>")
  )
```
