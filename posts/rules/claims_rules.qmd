---
title: "Building Claims Rules"
format: 
  html:
    reference-location: block
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false
knitr::opts_chunk$set(
  dev        = "ragg_png",
  dpi        = 300,
  out.width  = "100%",
  fig.width  = 8,
  fig.asp    = 0.618,
  fig.retina = 2,
  fig.align  = "center",
  fig.show   = "hold")

options(scipen = 999)
library(here)
library(tidyverse)
library(gt)
library(fuimus)
library(S7)

head_tail <- function(x, n = 5, by = NULL) {
  dplyr::bind_rows(
    dplyr::slice_head(x, n = n, by = dplyr::all_of(by)),
    dplyr::slice_tail(x, n = n, by = dplyr::all_of(by)))
}

rules <- read_csv(
  here("posts/rules/data/rules_raw.csv"),
  col_types = cols(
  row       = col_integer(),
  id_rule   = col_integer(),
  id_name   = col_character(),
  id_order  = col_integer(),
  category  = col_factor(),
  alert     = col_character(),
  var       = col_character(),
  action    = col_character(),
  value     = col_character(),
  rule      = col_character(),
  x9        = col_character(),
  x10       = col_character())) |> 
  mutate(
    category = remove_quotes(as.character(category)),
    category = str_remove_all(category, "\\r|\\n"),
    alert = remove_quotes(alert),
    alert = str_remove_all(alert, "\\r|\\n"),
    rule = remove_quotes(rule),
    rule = str_remove_all(rule, "\\r|\\n")) |> 
  fill(rule) |> 
  select(
    index = row,
    number = id_rule,
    order = id_order,
    identifier = id_name,
    variable = var,
    action,
    value,
    category,
    definition = rule,
    rationale  = alert
  )

rules[1, 4, drop = TRUE] <- "HCPCS:1"
rules[2, 4, drop = TRUE] <- "HCPCS:1"
rules[1, 9, drop = TRUE] <- "CPT Code is [43760] AND Encounter Date of Service after [01/01/2019]"
rules[2, 9, drop = TRUE] <- "CPT Code is [43760] AND Encounter Date of Service after [01/01/2019]"

descriptors <- rules |> 
  select(index, number, identifier, category, definition, rationale) |> 
  distinct() |> 
  mutate(source = str_extract_all(category,"https?://[^\\s]+"),
         category = str_remove_all(category,"https?://[^\\s]+")) |>
  unnest(source, keep_empty = TRUE) |>
  separate_longer_delim(source, delim = "https:") |>
  mutate(source = na_if(source, "") |> str_squish(),
         source = if_else(!is.na(source), str_c("https:", source), source),
         category = na_if(category, "") |> str_squish(),
         definition = str_squish(definition),
         definition = str_remove_all(definition, "►"),
         definition = gsub(",(?!\\s)", ", ", definition, perl = TRUE) |> str_squish(),
         rationale = str_squish(rationale),
         rationale = str_remove_all(rationale, "►"),
         rationale = gsub(",(?!\\s)", ", ", rationale, perl = TRUE) |> str_squish())

identifier <- descriptors |> 
  distinct(number, identifier) |> 
  reframe(number,
          identifier = str_remove_all(identifier, "-"),
          payer = if_else(str_detect(identifier, "BCBS|MCD|VFC"), str_extract(identifier, "BCBS|MCD|VFC"), NA_character_),
          state = if_else(!is.na(payer), str_extract(identifier, paste0(state.abb, collapse = "|")), NA_character_),
          split = strex::str_split_by_numbers(identifier)) |> 
  unnest_wider(split, names_sep = "_") |> 
  mutate(split_1 = case_match(
    split_1,
    c("VACCN", "COVID") ~ "VAX",
    "ICD" ~ "ICD:CM",
    "ANEST" ~ "ANES",
    "TELEH" ~ "TELE",
    "DIGES" ~ "GASTRO",
    "PRVNT" ~ "PREVENT",
    "OPTHL" ~ "OPHTH",
    "FOOT" ~ "PODIA",
    "FERTL" ~ "FERT",
    .default = split_1)) |> 
  group_by(payer) |> 
  mutate(split_2 = if_else(!is.na(payer), row_number(), as.integer(split_2))) |> 
  ungroup() |>
  mutate(split_2 = str_pad(as.character(as.integer(split_2)), width = 3, side = "left", pad = "0")) |> 
  fuimus::combine(name = payer_state, columns = c("payer", "state"), sep = ":") |> 
  mutate(split_1 = if_else(!is.na(payer_state), payer_state, split_1),
         payer_state = NULL) |> 
  fuimus::combine(name = identifier, columns = c("split_1", "split_2"), sep = ":") |> 
  mutate(split_1 = NULL,
         identifier = str_replace(identifier, "VAX:19", "VAX:00"),
         identifier = str_replace(identifier, "ICD:CM:10", "ICD:CM:"))

descriptors <- descriptors |> 
  select(-identifier) |> 
  left_join(identifier, by = "number") |> 
  relocate(identifier, .before = category)

components <- rules |> 
  select(number, order, variable, action, value) |> 
  distinct() |> 
  left_join(identifier, by = "number") |> 
  relocate(identifier, .before = variable) |> 
  mutate(variable = case_match(variable,
      c("CPT CODE", 
        "CPT Code", 
        "CPT code", 
        "CPT", 
        "Code Check Expired CPT Alert (Presence)", 
        "CPT is one of") ~ "hcpcs",
      c("Mod1", 
        "CPT Mod1", 
        "CPT Mod 1", 
        "CPTMod1", 
        "Code Check CPT Mod Alert (Presence)", 
        "CPT MOD1", 
        "CPT Mod1 (Presence)") ~ "mod_1",
      c("Mod2", 
        "CPT MOD2", 
        "CPT Mod 2", 
        "CPT Mod2 (Presence)", 
        "CPTMod2", 
        "CPT Mod2") ~ "mod_2",
      "CPT Mod3" ~ "mod_3",
      "CPT Mod4" ~ "mod_4",
      "CPT Units" ~ "unit",
      c("Dx code", 
        "DX Code", 
        "Dx Code", 
        "Code Check Expired DX Alert (Presence)") ~ "icd",
      c("Encounter Date of Service", 
        "Date of Service") ~ "dos",
      c("Location", 
        "Place of Service") ~ "pos",
      c("CPT UB04", 
        "UB04 Bill Type") ~ "ub04",
      "CPT NDC (Presence)" ~ "ndc",
      "CPT Rev Code" ~ "rev_code",
      "Code Check CCI Alert (Presence)" ~ "cci",
      "Code Check LCD Alert (Presence)" ~ "lcd",
      "Code Check NCD Alert (Presence)" ~ "ncd",
      c("Patient Age", 
        "Code Check Age Alert (Presence)") ~ "dob",
      c("Patient Sex", 
        "Code Check Gender Alert (Presence)") ~ "sex",
      "NA" ~ NA_character_,
      "Rendering Provider" ~ "rendering",
      "Referring Provider (Presence)" ~ "referring",
      c("Primary Insurance Class", 
        "Primary Insurance class", 
        "Primary insurance class") ~ "primary_class",
      "Primary Insurance" ~ "primary_name",
      "Secondary Insurance Class" ~ "secondary_class",
      "Secondary Insurance" ~ "secondary_name",
      c("Primary Insurance Authorization (Presence)", 
        "Primary Insurance Authorization (Presence) is not [Present]") ~ "primary_auth",
      .default = variable) |> 
      as_factor()) |> 
  mutate(
    class = case_match(variable,
      c("sex", "rendering", "referring", 
        "primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name", "ncd", "lcd", 
        "cci", "ndc", "ub04", "pos", 
        "icd", "hcpcs", "mod_1", "mod_2", 
        "mod_3", "mod_4") ~ "<chr>",
      c("rev_code", "unit") ~ "<int>",
      c("dos", "dob") ~ "<date>"
    ) |> as_factor(),
    group = case_match(as.character(variable),
      c("sex", "dos", "dob") ~ "patient",
      c("rendering", "referring") ~ "provider",
      c("hcpcs", "mod_1", "mod_2", "mod_3", "mod_4", 
        "rev_code", "unit", "ndc", "pos") ~ "procedure",
      c("icd") ~ "diagnosis",
      c("ub04", "1500") ~ "claim",
      c("ncd", "lcd", "cci") ~ "ncci",
      c("primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name") ~ "payer"
    ) |> as_factor())
```


# Anatomy of a Rule

   - Rule class
      - `identifier`: Unique Alphanumeric Identifier; `<Primary Key>`
      - `category`: High-Level Classification
      - `definition`: Human Readable Description of Rule Steps
      - `rationale`: Reason for Implementation
      - `sources`: URLs, References, or Documentation
      - `steps`: List of Steps to Evaluate
  
  - Step class
      - `order`: Indicates validation step order. Certain steps must be ahead of others, e.g. dos should always be first
         - qualifier: identifies records that meet the evaluation criteria; ignored if criteria is not met
         - final step: result indicates a pass or fail
      - `variable`: element of claim to evaluate
      - `method`:
          - regex: for matching patterns of long lists of HCPCS codes
          - logical
          - unary
          - binary
          - calculation: days elapsed between date of birth and date of service
      - `expression`: functional code to call
      - `value`: must be a valid instance of variable, expected state is evaluated against this value

      
  - `variable` classes:
     - Insurance (`payer`)
       - `name`: BCBS, Medicaid, etc.
       - `state`: State Abbreviation (optional)
       - `class`: Self-Pay, Commercial, Medicare, Medicaid, etc.
     - Date of Service (`dos`)
       - `date`: Date of Service
     - Diagnosis (`icd`)
       - `code`: ICD-10 Code
     - Provider (`provider`)
       - `name`: Provider Name
       - `npi`: NPI
       - `type`: Rendering, Referring
       - `credential`: MD, DO, etc.
     - Procedure (`hcpcs`)
       - `code`: HCPCS Code
       - `mod_1`: Modifier 1
       - `mod_2`: Modifier 2
       - `mod_3`: Modifier 3
       - `mod_4`: Modifier 4
       - `unit`: Number of Units
     - NDC (`ndc`)
       - `code`: NDC Code


```{r}
rules[1, ] |> glimpse()
rules[2, ] |> glimpse()
```

```{r}
rules[3, ] |> glimpse()
rules[4, ] |> glimpse()
rules[5, ] |> glimpse()
rules[6, ] |> glimpse()
```


## S7 Class

```{r}
crule <- S7::new_class(
  "crule",
  package = "cruler",
  properties = list(
    identifier = S7::class_character,
    category = S7::class_character,
    definition = S7::class_character,
    rationale = S7::class_character,
    source = S7::new_property(class = S7::class_character, default = NA_character_),
    steps = S7::new_property(class = S7::class_list, default = list()),
    timestamp = new_property(class = S7::class_POSIXct, default = as.POSIXct(Sys.time()))
    )
  )

crule

hcpcs_exp <- crule(
  identifier = "HCPCS:EXP:001",
  category = "Invalid HCPCS",
  definition = "<Date of Service> is [2019-01-01] or after |AND| <HCPCS Code> is [43760]",
  rationale = "Effective 2019-01-01, HCPCS 43760 is invalid; See 43762 - 43763",
  source = "https://www.cms.gov/Medicare/Coding/HCPCSReleaseCodeSets/Alpha-Numeric-HCPCS")

hcpcs_exp

cvariable <- S7::new_class(
  "cvariable",
  package = "cruler",
  properties = list(
    name = S7::class_character,
    group = S7::class_character,
    attributes = S7::class_list
    )
  )

cvariable
```

```{r}
#| label: qualify
#| echo: true
#| message: false
#| warning: false
#| error: true
rule_001_example <- dplyr::tibble(
  dos = as.Date(c("2024-01-01", "2018-01-01")),
  hcpcs = as.character(c(43760, 43760))
)

rule_001_example2 <- dplyr::tibble(
  dos = as.Date(c("2017-01-01", "2018-01-01")),
  hcpcs = as.character(c(43760, 43760))
)

qualify_date <- function(df) {
  
  arg  <- rlang::caller_arg(df)
  call <- rlang::caller_env()
  
  x <- vctrs::vec_slice(df, df[["dos"]] >= as.Date("2019-01-01"))
  
  if (vctrs::vec_is_empty(x))  {
    cli::cli_abort(
      "No matches for {.strong dos} >= {.val {as.Date('2019-01-01')}} in {.arg {arg}}.", 
      arg = arg,
      call = call,
      class = "check_length"
      )
  }
  return(x)
}


qualify_date(rule_001_example)

qualify_date(rule_001_example2)
```





## Descriptors

-   [X] `identifier`
-   [X] `name`: Split letters/numbers, categorize Payer, State, etc.
-   [X] `category`: 
-   [ ] `description`:
-   [ ] `rationale`: Steps are detailed in the rationale that are missing from the ruleset
-   [X] `sources`: Extract urls from `category`

### Cleaning: Category

URLs -> Source

```{r}
#| label: descriptors
#| echo: true
#| message: false
#| warning: false
descriptors |> 
  select(category, rationale) |> 
  filter(!is.na(category)) |> 
  distinct(category) |> 
  print(n = 500)
```


### Sample

```{r}
#| label: category
#| echo: true
#| message: false
#| warning: false
descriptors |>
  slice_sample(n = 15) |> 
  mutate(category = str_wrap(category, width = 50),
         definition = str_replace_all(definition, " AND ", "<br><br><b>&&</b><br><br>") |> str_wrap(width = 60),
         definition = str_replace_all(definition, " OR ", "<br><br><b>||</b><br><br>") |> str_wrap(width = 60),
         definition = str_remove_all(definition, regex("\\s*\\(\\s*\\d+\\s*\\)\\s*")) |> str_wrap(width = 60),
         definition = str_squish(definition),
         rationale = str_wrap(rationale, width = 50)) |>
  select(-source, -index) |> 
  gt(rowname_col = "identifier",
     row_group_as_column = TRUE) |>
  fmt_markdown(columns = c("definition")) |>
  cols_align(align = "left", columns = -c(number)) |>
  cols_align(align = "center", columns = c(number)) |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = "left",
        weight = "bold",
        size = px(14),
        whitespace = "break-spaces",
        font = google_font(name = "JetBrains Mono")),
      locations = cells_body(columns = c(definition))) |>
  tab_style(
      style = cell_text(
        color = "#0B0B35",
        align = "center",
        weight = "bold",
        size = px(16),
        font = google_font(name = "Roboto Condensed")),
      locations = cells_body(columns = c(number))) |>
  sub_missing(missing_text = "NO CATEGORY") |>
  gtExtras::gt_add_divider(
    columns = "category", 
    style = "solid",
    weight = "3px",
    color = "royalblue") |>  
  gtExtras::gt_merge_stack(
    col1 = "category",
    col2 = "rationale",
    font_size = c("17px", "16px"),
    palette = c("darkgreen", "royalblue"),
    font_weight = c("bold", "normal"),
    small_cap = FALSE
  ) |> 
  tab_style(
    style = cell_text(
      v_align = "middle", 
      align = "right",
      weight = "800"),
    locations = cells_row_groups()) |> 
  tab_style(
    style = cell_text(
      size = px(16),
      font = google_font(name = "JetBrains Mono"),
      v_align = "middle", 
      align = "right"
      ),
    locations = cells_stub()) |> 
  opt_stylize(add_row_striping = TRUE) |>
  tab_options(table.width = pct(85),
              quarto.disable_processing = TRUE)
```


## Components

-   [ ] `step`: 
-   [X] `variable`: Recode to standardize
-   [ ] `class`: Variable Data Class
-   [ ] `group`: Variable Grouping
-   [ ] `action`: Remove
-   [ ] `method`: Operation Performed to Test for Expected State
-   [ ] `expression`: Actual Code to Run
-   [ ] `value`: Coerce to correct data type, deal with wildcards

```{r}
#| label: components
#| echo: true
#| message: false
#| warning: false
components
```


### Variable

   - `hcpcs`: 
   - `mod_1`: 
   - `mod_2`:
   - `mod_3`:
   - `mod_4`:
   - `unit`: 
   - `icd`:
   - `dos`:
   - `pos`:
   - `ub04`:
   - `ndc`:
   - `rev_code`:
   - `cci`:
   - `lcd`:
   - `ncd`:
   - `dob`:
   - `sex`:
   - `rendering`:
   - `referring`:
   - `primary_class`:
   - `primary_name`:
   - `primary_auth`:
   - `secondary_class`:
   - `secondary_name`:



```{r}
#| label: class_group
#| echo: true
#| message: false
#| warning: false
components  |> 
  filter(!is.na(class)) |>
  distinct(class, group, variable, action) |>
  count(class, group, variable, name = "actions") |>
  arrange(class, group, desc(actions)) |>
  gt(groupname_col = "class",
     rowname_col = "group",
     row_group_as_column = TRUE
     ) |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "JetBrains Mono"),) |>
  opt_all_caps(locations = c("column_labels")) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        font = google_font(name = "Roboto Mono")),
      locations = cells_stub()) |>
  tab_style(
      style = cell_text(
        color = "royalblue",
        align = 'right',
        weight = "normal",
        # style = "italic",
        decorate = "underline",
        # stretch = "condensed",
        size = px(20),
        font = google_font(name = "Fira Code")),
      locations = cells_row_groups()) |>
  opt_stylize() |>
  tab_options(table.width = pct(50),
              quarto.disable_processing = TRUE)
```

#### Date of Service

```{r}
components |> 
  filter(variable == "dos") |> 
  mutate(class = "<date>",
         value = anytime::anydate(value),
         method = if_else(str_detect(action, "after"), ">", "<")) |> 
  select(number, order, class, group, variable, action, value) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, action, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  opt_stylize() |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### Patient Age

All ages should be in the same unit of time, in this case, days.

Should be calculated from the encounter's Date of Service (`dos`) and the patient's Date of Birth (`dob`).

```{r}
components |> 
  filter(variable == "dob") |> 
  mutate(variable = "age",
         class = "<int>", 
         age = strex::str_extract_numbers(value),
         period = strex::str_extract_non_numerics(value),
         .before = variable) |> 
  unnest(c(age, period)) |> 
  mutate(
    age = as.integer(age),
    period = str_remove_all(period, "\\s|,"),
    value = NULL,
    method = case_match(
      action,
      c("is younger than", "younger than") ~ "<",
      "is older than" ~ ">",
      "is" ~ "==",
      .default = NA_character_),
    days = case_when(
      period == "years" ~ as.duration(years(age)) / ddays(1),
      period == "months" ~ as.duration(months(age)) / ddays(1),
      period == "days" ~ as.duration(days(age)) / ddays(1),
      .default = NA_real_),
    dos = lubridate::today(),
  ) |> 
  select(number, order, class, variable, method, age, period, days) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  fmt_integer(columns = c("age", "days")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### Unit (HCPCS)

```{r}
components |> 
  filter(variable == "unit") |> 
  mutate(class = "<int>", 
         value = as.integer(value),
         method = if_else(str_detect(action, "is not"), "!=", "=="),
         .before = variable) |> 
  select(number, order, class, variable, method, value, action) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### NDC

How can this be represented in relational algebra? Detect presence with regex?

If not present, then is `NA` its' representation? If so, `is.na(x)` would equal `is not present` and `!is.na(x)` would equal `is present`


```{r}
components |> 
  filter(variable == "ndc") |> 
  mutate(class = "<lgl>", 
         .before = variable, 
         method = if_else(str_detect(action, "is not"), "is.na(x)", "!is.na(x)")) |> 
  select(number, order, class, variable, method, value, action) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```

#### ICD

   * has all
   * is
   * is not
   * is one of

some values contain wildcards *

```{r}
components |> 
  filter(variable == "icd") |>
  mutate(wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         nchar = if_else(wc == 1, str_count(value, "[[:alnum:]]"), 0L),
         class = "<chr>",
         method = case_when(
           action == "is" & wc == 1 ~ "%in%",
           action == "is" & wc == 0 ~ "==",
           .default = NA_character_)
         ) |> 
  filter(!is.na(method)) |> 
  select(number, order, class, variable, method, value, action, wc, nchar) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method, value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```


#### HCPCS

```{r}
components |> 
  filter(variable == "hcpcs") |>
  mutate(wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         nchar = if_else(wc == 1, str_count(value, "[[:alnum:]]"), 0L),
         class = "<chr>",
         method = case_when(
           action == "is" & wc == 1 ~ "%in%",
           action == "is" & wc == 0 ~ "==",
           .default = NA_character_),
         value = str_replace_all(value, "\\s|,", " "),
         value = str_wrap(value, width = 30)
         ) |> 
  filter(!is.na(method)) |> 
  select(number, order, class, variable, method, value, action, wc, nchar) |> 
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(variable, method))) |>
  tab_style(
      style = cell_text(
        align = "left",
        weight = "bold",
        size = px(14),
        whitespace = "break-spaces",
        font = google_font(name = "JetBrains Mono")),
      locations = cells_body(columns = c(value))) |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        style = "italic",
        decorate = "underline",
        stretch = "condensed",
        font = google_font(name = "Fira Code")),
      locations = cells_body(columns = c(class))) |>
  tab_options(table.width = pct(75),
              quarto.disable_processing = TRUE)
```



## Unevaluated Code

```{r}
#| label: vars
#| echo: true
#| eval: false
#| message: false
#| warning: false
categorize_vars |>
  separate_longer_delim(cols = value, delim = ",") |>
  mutate(value = str_squish(value),
         neg = case_when(str_detect(action, "not") ~ 1L, .default = 0L),
         wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
         .after = value)

head_tail(rules_new, n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action, value))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)

rules_new |>
  filter(!is.na(var)) |>
  group_by(var) |>
  count(action) |>
  ungroup() |>
  arrange(var, desc(n), action) |>
  gt(groupname_col = "var", row_group_as_column = TRUE) |>
  cols_align(align = "left") |>
  opt_table_font(
    font = google_font(name = "Roboto Condensed"),
    weight = "bold"
    ) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "normal",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(var, action))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```


### Regexes

```{r}
#| label: regex
#| eval: false
#| echo: true
#| message: false
#| warning: false

c(
  "^[9][0][4][7][67]$"     = '9047(6|7)', 
  "^[9][0][56][1-9][0-9]$" = '905*|906*', 
  "^[9][0][7][1-5][02-9]$" = '907(1|2|3|4|5)',
  "^[9][1][3][01][0-9]$"   = '913'
  )

rules_new |>
  filter(wc == 1,
         var == "hcpcs") |>
  mutate(value = str_remove_all(value, "\\*"),
         chars = 5 - str_length(value),
         .after = value) |>
  mutate(
    regex = case_when(
      chars == 0 ~ glue_chr("^<<value>>$", .open = "<<", .close = ">>"),
      chars == 1 ~ glue_chr("^<<value>>[0-9]$", .open = "<<", .close = ">>"),
      chars > 1 ~ glue_chr("^<<value>>[0-9]{<<chars>>}$", .open = "<<", .close = ">>")),
    regex = case_when(neg == 1L ~ glue_chr('!{regex}'), .default = regex),
    .after = regex
  ) |>
  head_tail(n = 10, by = c("var", "action")) |>
  gt() |>
  cols_align(align = "left") |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = 'left',
        weight = "bold",
        font = google_font(name = "Roboto Mono")),
      locations = cells_body(columns = c(regex))) |>
  tab_options(table.width = pct(100),
              quarto.disable_processing = TRUE)
```


### HCPCS Search

```{r}
#| label: misc
#| eval: false
#| echo: true
#| message: false
#| warning: false
northstar::search_descriptions(hcpcs_desc_type = "Long") |> 
  # dplyr::mutate(not_hcpcs = !grepl("^99[0-9]{3}$", hcpcs_code)) |> 
  filter(!grepl("^99[0-9]{3,3}$", hcpcs_code)) |>
  # dplyr::mutate(has_hcpcs = grepl("^J[0-9]{4}$", hcpcs_code)) |> 
  filter(str_detect(hcpcs_code, regex("^J[0-9]{4}$"))) |> 
  filter(str_detect(hcpcs_code, regex("^(?!5405)(?<![0-9]{1})$"))) |> 
  print(n = 200)

# Match strings that don't start with "99" and don't end with 3 digits
pattern <- "^(?!99).*(?<![0-9]{3})$"

# Negation pattern
"^(?!9938[0-9]{1}$)"

# Begins with 0, ends with digit
"^0.*\\d$"

# Begins with 0, ends with letter
"^0.*[A-Z]$"

# Match strings that don't start with "a" and don't end with "z"
pattern <- "^(?!a).*[^z]$"
grep(pattern, c("apple", "banana", "cherry"), value = TRUE)
# Output: "banana" "cherry"

stringr::str_detect("99202", stringr::regex("^[992]{3}.*"))

grep("^[992]{3}.*", "99202", value = TRUE, invert = TRUE)


pattern = dplyr::case_when(
  chars == 0 & negation == FALSE ~ glue::glue("^<value>$", .open = "<", .close = ">"),
  chars > 0  & negation == FALSE ~ glue::glue("^<value>[0-9]{<chars>}$", .open = "<", .close = ">"),
  chars == 0 & negation == TRUE ~ glue::glue("^(?!<value>)$", .open = "<", .close = ">"),
  chars > 0  & negation == TRUE ~ glue::glue("^(?!<<value>>)(?<![0-9]{<<chars>>})$", .open = "<<", .close = ">>")
  )
```
