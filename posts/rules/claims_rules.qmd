---
title: "Building Claims Rules"
format: 
  html:
    reference-location: block
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false
knitr::opts_chunk$set(
  dev        = "ragg_png",
  dpi        = 300,
  out.width  = "100%",
  fig.width  = 8,
  fig.asp    = 0.618,
  fig.retina = 2,
  fig.align  = "center",
  fig.show   = "hold")

options(scipen = 999)
library(here)
library(gt)
library(S7)

source(here("posts/rules/scripts", "load.R"))
```


# Anatomy of a Rule

   - `rule` class
      - `identifier`: Unique Alphanumeric Identifier; `<Primary Key>`
      - `category`: High-Level Classification
      - `definition`: Human Readable Description of Rule Steps
      - `rationale`: Reason for Implementation
      - `source`: URLs, References, or Documentation
      - `steps`: List of Steps to Evaluate
  
  - `step` class
      - `type`: `qualifier` or `terminator`
         - `qualifier`s: identifies records that meet the evaluation criteria; record is skipped if criteria is not met
         - `terminator`: result indicates a pass or fail
      - `order`: Validation step order. Certain steps must be ahead of others, e.g. `dos` should always be first
      - `variable`: element of claim to evaluate
      - `value`: valid variable instance, expected state evaluated against it
      - `condition`: functional code to call based on method selected
      - `alert`: message to display if `terminator` condition is not met 
      - `method`: could define different methods for a single variable
          - regex: for matching patterns of long lists of HCPCS codes
          - calculation: days elapsed between date of birth and date of service
          - comparison: check if a value is greater than or less than another value
          - equality: check if a value is equal to another value
          - presence: check if a value is present

      
  - `variable` classes:
     - Insurance `type`: Primary, Secondary, Tertiary
        - Insurance `class`: Self-Pay, Commercial, Medicare, Medicaid, etc.
           - Insurance `payer`
             - `name`: BCBS, Medicaid, etc.
             - `state`: State Abbreviation (optional)
     - Date of Service (`dos`)
     - ICD-10 Code (`icd`)
     - Provider (`provider`)
       - `role`: Rendering, Referring
       - `credential`: MD, DO, etc.
     - Procedure (`hcpcs`)
       - `code`: HCPCS Code
       - `mod_1`: Modifier 1
       - `mod_2`: Modifier 2
       - `mod_3`: Modifier 3
       - `mod_4`: Modifier 4
       - `unit`: Number of Units
     - NDC Code (`ndc`)
     - Revenue Code (`rev_code`)
     - Place of Service (`pos`)
        - `code`: 02, 11, etc.
        - `type`: Facility, Non-Facility
        - `description`: Hospital, Clinic, etc.
     - Patient:
        - Age (`age`)
        - Sex (`sex`)
     - Claim
        - type: Institutional (`ub04`), Professional (`1500`)
     

## S7 Class

```{r}
#| label: s7_class
#| echo: false
#| eval: false
#| message: false
#| warning: false

Sys.Date() - (as.duration(years(21)) / ddays(1))

encounter <- S7::new_class(
  name = "encounter",
  package = "cruler",
  properties = list(
    dos = S7::class_Date,
    pos = S7::class_character,
    referring = S7::class_character,
    rendering = S7::class_character
    )
  )


patient <- S7::new_class(
  name = "patient",
  package = "cruler",
  properties = list(
    dob = S7::class_Date,
    sex = S7::class_character,
    age = S7::new_property(
      class = S7::class_integer, 
      getter = function(self) {
        as.integer(Sys.Date() - self@dob)
      })
    )
  )

patient(dob = as.Date("2003-09-04"), sex = "Male")

payer <- S7::new_class(
  name = "payer",
  package = "cruler",
  properties = list(
    hierarchy = S7::new_property(
      class = S7::class_character, 
      default = c("Primary", "Secondary", "Tertiary"),
      setter = function(self, value) {
        self@hierarchy = match.arg(value, c("Primary", "Secondary", "Tertiary"))
        self
      }),
    name = S7::class_character,
    state = S7::new_property(
      class = S7::class_character, 
      default = state.abb,
      setter = function(self, value) {
        self@state = match.arg(value, state.abb)
        self
      }),
    classification = S7::new_property(
      class = S7::class_character, 
      getter = function(self) {
        dplyr::case_match(
          self@name,
          "BCBS" ~ "Commercial",
          "Medicaid" ~ "Medicaid",
          "Medicare" ~ "Medicare",
          "Patient" ~ "Self-Pay",
          .default = "Other"
          )
      }
    )#,
  #   validator = function(self) {
  #   if (length(self@hierarchy) != 1) return("@hierarchy must be length 1")
  #   if (length(self@name) != 1) return("@name must be length 1")
  #   if (!missing(self@state)) {
  #     if (length(self@state) != 1) return("@state must be length 1")
  #     if (nchar(self@state) != 2) return("@state must be 2 characters")
  #     if (!self@state %in% state.abb) return("@state must be a valid abbreviation")
  #   }
  # }
  )
)

payer()

bcbcs_ex <- payer("Primary", "BCBS", "TX")

bcbcs_ex@hierarchy
bcbcs_ex@classification
bcbcs_ex@state

step <- S7::new_class(
  name = "step",
  package = "crule",
  properties = list(
    order = S7::class_integer,
    element = element,
    value = S7::new_property(class = S7::class_any)
    ),
  validator = function(self) {
    if (length(self@order) != 1)    {"@order must be length 1"}
    if (length(self@variable) != 1) {"@variable must be length 1"}
  })

rule <- S7::new_class(
  name = "rule",
  package = "crule",
  properties = list(
    index = S7::class_integer,
    identifier = S7::class_character,
    category = S7::class_character,
    definition = S7::class_character,
    rationale = S7::class_character,
    alert = S7::class_character,
    timestamp = S7::new_property(class = S7::class_Date, default = Sys.Date()),
    steps = step
    )
  )

step

step()

rule

rule()


hcpcs_exp <- rule(
  index = 1L,
  identifier = "HCPCS:EXP:001",
  category = "Invalid HCPCS",
  definition = "<DOS> is after [2019-01-01] AND <HCPCS> is [43760]",
  rationale = "Effective 2019-01-01, HCPCS 43760 is invalid",
  alert = "See HCPCS [43762, 43763]",
  steps = c(
    dos = step(order = 1L,
               variable = "dos",
               value = as.Date(c("2019-01-01", "2019-01-01"))),
    hcpcs = step(order = 2L,
                 variable = "hcpcs",
                 value = c("43760"))
    )
  )

hcpcs_exp



dos_var <- step(
  order = 1L,
  variable = "dos",
  value = "2019-01-01"
)

dos_var@condition("2020-01-01")
```



```{r}
#| label: qualify
#| echo: false
#| eval: false
#| message: true
#| warning: true
#| error: true
rule_001_example <- dplyr::tibble(
  dos = as.Date(c("2024-01-01", "2018-01-01")),
  hcpcs = as.character(c(43760, 99213))
)

rule_001_example

rule_001_example2 <- dplyr::tibble(
  dos = as.Date(c("2017-01-01", "2018-01-01", "2019-01-01")),
  hcpcs = as.character(c(99213, 99213, 99213))
)

rule_001_example2

qualify_dos <- function(df, dos, date) {
  
  arg  <- rlang::caller_arg(dos)
  call <- rlang::caller_env()
  
  x <- vctrs::vec_slice(df, df[[dos]] > date)
  
  if (vctrs::vec_is_empty(x))  {
    cli::cli_inform(
      "0 matches for {.strong {.val {rlang::sym(dos)}}} > {.val {as.Date(date)}}", 
      arg = arg,
      call = call,
      class = "qualify_dos"
      )
  }
  x
}

rule_001_example |> 
  qualify_dos("dos", "2019-01-01")

rule_001_example2 |> 
  qualify_dos("dos", "2019-01-01")

term_hcpcs <- function(df, hcpcs, code) {
  
  arg  <- rlang::caller_arg(hcpcs)
  call <- rlang::caller_env()
  
  x <- vctrs::vec_slice(df, df[[hcpcs]] == code)
  
  if (vctrs::vec_is_empty(x))  {
    cli::cli_inform(
      "0 matches for {.strong {.val {rlang::sym(hcpcs)}}} == {.val {rlang::sym(code)}}", 
      arg = arg,
      call = call,
      class = "term_hcpcs"
      )
  }
  x
}

rule_001_example |> 
  term_hcpcs("hcpcs", "43760")

rule_001_example2 |> 
  term_hcpcs("hcpcs", "43760")


rule_001_example |> 
  qualify_dos("dos", "2019-01-01") |> 
  term_hcpcs("hcpcs", "43760")

rule_001_example2 |> 
  qualify_dos("dos", "2019-01-01") |> 
  term_hcpcs("hcpcs", "43760")
```


## Cleaning Definitions

```{r}
print_desc(1)
print_desc(50)
print_desc(100)
print_desc(500)
print_desc(1000)
```


## Metadata

   * Rulesets
      * Identifiers: 712
      * Categories: 621
      * Definitions: 703
      * Rationales: 659
      * Sources: 2

-   [X] `index`: Row number
-   [X] `number`: Rule Number
-   [X] `identifier`: Split letters/numbers, categorize Payer, State, etc.
-   [ ] `category`: Categories make little sense, need to be reclassified
-   [ ] `definition`: Define Variables, Logic, Remove Parentheses
-   [ ] `rationale`: Steps are detailed in the rationale that are missing from the ruleset
-   [X] `source`??: Extract urls from `category`

Need to define `instruction`/`suggestion` variable, taken from `rationale`


```{r}
#| label: descriptors_gt
#| echo: false
#| eval: false
#| message: false
#| warning: false
descriptors |>
  gt() |> 
  gtExtras::gt_merge_stack(
    col1 = "category",
    col2 = "rationale",
    font_size = c("17px", "16px"),
    palette = c("darkgreen", "royalblue"),
    font_weight = c("bold", "normal"),
    small_cap = FALSE
  )
```

```{r}
#| label: sample
#| echo: false
#| eval: false
#| message: false
#| warning: false
descriptors |>
  slice_sample(n = 15) |> 
  mutate(
    category = str_wrap(category, width = 50),
    definition = str_replace_all(definition, " AND ", "<br><br><b>&&</b><br><br>") |>
      str_wrap(width = 60),
    definition = str_replace_all(definition, " OR ", "<br><br><b>||</b><br><br>") |>
      str_wrap(width = 60),
    definition = str_remove_all(definition, regex("\\s*\\(\\s*\\d+\\s*\\)\\s*")) |>
      str_wrap(width = 60),
    definition = str_squish(definition),
    rationale = str_wrap(rationale, width = 50)) |>
  select(-source, -index) |> 
  gt(rowname_col = "identifier",
     row_group_as_column = TRUE) |>
  fmt_markdown(columns = c("definition")) |>
  cols_align(align = "left", columns = -c(number)) |>
  cols_align(align = "center", columns = c(number)) |>
  opt_table_font(font = google_font(name = "Roboto Condensed")) |>
  opt_all_caps() |>
  tab_style(
      style = cell_text(
        align = "left",
        weight = "bold",
        size = px(14),
        whitespace = "break-spaces",
        font = google_font(name = "JetBrains Mono")),
      locations = cells_body(columns = c(definition))) |>
  tab_style(
      style = cell_text(
        color = "#0B0B35",
        align = "center",
        weight = "bold",
        size = px(16),
        font = google_font(name = "Roboto Condensed")),
      locations = cells_body(columns = c(number))) |>
  sub_missing(missing_text = "NO CATEGORY") |>
  gtExtras::gt_add_divider(
    columns = "category", 
    style = "solid",
    weight = "3px",
    color = "royalblue") |>  
  gtExtras::gt_merge_stack(
    col1 = "category",
    col2 = "rationale",
    font_size = c("17px", "16px"),
    palette = c("darkgreen", "royalblue"),
    font_weight = c("bold", "normal"),
    small_cap = FALSE
  ) |> 
  tab_style(
    style = cell_text(
      v_align = "middle", 
      align = "right",
      weight = "800"),
    locations = cells_row_groups()) |> 
  tab_style(
    style = cell_text(
      size = px(16),
      font = google_font(name = "JetBrains Mono"),
      v_align = "middle", 
      align = "right"
      ),
    locations = cells_stub()) |> 
  opt_stylize(add_row_striping = TRUE) |>
  tab_options(table.width = pct(85),
              quarto.disable_processing = TRUE)
```

## Components of A Step

Two types of a step: `qualifier` and `terminator`

A **qualifier** is basically a long `if (x & y & (a | b | c))` statement.


A **terminator** is the final step, analogous to a `stopifnot()` statement that checks the data.

-   [X] `number`:
-   [X] `order`:
-   [X] `identifier`:
-   [X] `variable`: Recode to standardize names
-   [X] `class`: Variable Data Class
-   [X] `group`: Variable Grouping
-   [X] `action`: Translate to `condition`
-   [X] `value`: Coerce to correct data type, deal with wildcards
-   [X] `condition`: Predicate function that evaluates to `TRUE` or `FALSE`

### Variables

-   [X] `dos`: 81
-   [X] `pos`: 142
-   [X] `ub04`: 106
-   [X] `age`: 158
-   [X] `sex`: 3
-   [X] `referring`: 14
-   [X] `rendering`: 20
-   [X] `icd`: 251
-   [X] `hcpcs`: 1071
-   [X] `mod_1`, `mod_2`, `mod_3`, `mod_4`: 472
-   [X] `unit`: 13
-   [X] `ndc`: 23
-   [X] `rev_code`: 19
-   [X] `primary_class`: 371
-   [X] `primary_name`: 132
-   [X] `primary_auth`: 3
-   [X] `secondary_class`: 6
-   [X] `secondary_name`: 4

#### Cleaned

```{r}
#| label: cleaned_steps
#| echo: true
#| eval: true
#| message: false
#| warning: false

dos <- Sys.Date()

condition <- cleaned_steps |> 
  select(condition) |> 
  slice(2) |> 
  pull(condition)

condition

condition |> 
  rlang::parse_expr() |> 
  rlang::eval_bare()

cleaned_steps
```


```{r}
#| label: cleaned_definitions
#| echo: true
#| eval: true
#| message: false
#| warning: false
cleaned_definitions
```

```{r}
#| label: descriptors
#| echo: true
#| eval: true
#| message: false
#| warning: false
descriptors
```
