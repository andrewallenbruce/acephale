---
title: "Building an NPI Constructor"
subtitle: "Validating National Provider Identifiers with Luhn's Algorithm"
description: "A guide to National Provider Identifiers and the CMS standard for NPI validation."
format:
  html:
    reference-location: block
    other-links:
      - text: Luhn Algorithm
        icon: bookmark-plus
        href: https://en.wikipedia.org/wiki/Luhn_algorithm
      - text: CMS NPI Standard
        icon: bookmark-plus
        href: https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf
      - text: CMS-10114 NPI Application
        icon: bookmark-plus
        href: https://www.cms.gov/medicare/cms-forms/cms-forms/downloads/cms10114.pdf
---

```{r setup}
#| message: false
#| warning: false
#| echo: false
#| cache: false

knitr::opts_chunk$set(
  collapse  = FALSE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "",
  dpi       = 600, 
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)
options(scipen = 999)

library(tidyverse)
library(downlit)
library(rlang)
library(cli)
```


The National Provider Identifier (NPI) is a unique 10-digit identification number assigned to health care providers in the United States through NPPES. The Centers for Medicare & Medicaid Services (CMS) developed the NPI as a way to standardize the identification of health care providers across the health care industry. [NPPES](https://npiregistry.cms.hhs.gov/search) is the National Plan and Provider Enumeration System (NPPES) NPI Registry, a free directory of all active NPI records.

# CMS NPI Standard {#sec-cmsstandard}

The following is an excerpt from the CMS document on the NPI check digit calculation, [Requirements for National Provider Identifier (NPI) and NPI Check Digit (2004-01-23)](https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf).

## NPI Requirements {#sec-requirements}
   
   * Consist of 10 numeric digits. The 10<sup>th</sup> digit is the check digit.
   
   * Have no embedded intelligence.
   
   * Begin with a `1` or `2`.
[Use of other first digits for the NPI must be coordinated with the use of first digits by the standard health plan identifier, when it is adopted.]{.aside}
   
   * Generated by a scattering algorithm using all possible numeric combinations.
   
   * Be unique, without requiring database access for verification.

## NPI Check Digit {#sec-checkdigit}

The check digit is calculated using the [Luhn formula](https://en.wikipedia.org/wiki/Luhn_algorithm) for computing the modulus 10 “double-add-double” check digit. [This algorithm is recognized as an ISO standard and is the specified check digit algorithm to be used for the card issuer identifier on a standard health identification card.]{.aside}

When an NPI is used as a card issuer identifier on a standard health identification card, it is preceded by the prefix **80840**, in which **80** indicates *health applications* and **840** indicates the *United States*.

To enable this feature for any NPI, the check digit will always be calculated as if the prefix is present. 

For a non-prefixed NPI, this is accomplished by adding the constant **24** in step 2 of the check digit calculation.

## Check Digit Calculation

The check digit formula (Luhn Modulus 10 *double-add-double*) is calculated as follows:

   1. Beginning with the rightmost digit, double the value of the alternate digits.
   
   1. Add the individual digits of the products from Step 1 to the unaffected digits from the original number.
   
   1. Subtract the result of step 2 from the next highest number ending in zero. This is the check digit.


::: {#note-mod .callout-note}

### Multiples of Ten

The *next highest number ending in zero* is simply the next multiple of ten. 

Specifically, for some number $n$, the next multiple of ten would be $n + (10 - (n \mod 10))$:

```{r}
next_mult_10 <- \(n) n + (10 - (n %% 10))
```

For example, if $n$ is `23`, the next multiple of ten is `30`:

```{r}
next_mult_10(23)
```

If $n$ is a multiple of ten, such as `50`, the next multiple of 10 is `60`:

```{r}
next_mult_10(50)
```


::: 

-----------------------------------------------------------------

### Check Digit Calculation Examples

::: {.panel-tabset}

## With Prefix

> Assume the prefixed 9-position identifier is `80840123456789`:

```{r}
make_prefix <- \(x, y) {
  as.integer(
    unlist(
      strsplit(
        paste0(x, y), 
        "")
    )
  )
}

(x <- make_prefix(80840, 123456789))
```

> Beginning on the right, double the alternate digits:
>
> `8 0 8 8 0 2 2 6 4 10 6 14 8 18`

```{r}
double_alts <- \(x) {
  x <- rev(x)
  
  idx <- seq(1, length(x), 2)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

(x <- double_alts(x))
```

> Add the individual digits of products of doubling, plus unaffected digits: 
> 
> `8 + 0 + 8 + 8 + 0 + 2 + 2 + 6 +` 
> `4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67`


```{r}
sum_digits <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    )
}

(x <- sum_digits(x))
```

> Subtract result from the next multiple of 10: `70 – 67 = 3`
> This is the check digit.


```{r}
get_check <- \(x) {
  ceiling(x / 10) * 10 - x
}

(x <- get_check(x))
```

> Append the check digit to the the card issuer identifier: `808401234567893`

```{r}
prefix_check <- \(pre, check) {
  paste0(pre, check)
}

prefix_check(80840123456789, x)
```

## Without Prefix

> Assume the 9-position identifier is `123456789`

```{r}
make_id <- \(x) {
  as.integer(
    unlist(
      strsplit(
        as.character(x), ""
        )
      )
    )
}

(xx <- make_id(123456789))
```

> Beginning on the right, double the alternate digits:
> `2 4 6 9 10 14 18`
> `2  2  6  4 10  6 14  8 18`

```{r}
double_alts <- \(x) {
  x <- rev(x)
  
  idx <- seq(1, length(x), 2)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

(xx <- double_alts(xx))
```

> Add constant 24 to the sum of the individual digits: 
> `24 + 2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67`


```{r}
sum_digits_24 <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    ) + 24
}

(xx <- sum_digits_24(xx))
```

> Subtract result from the next multiple of 10: `70 – 67 = 3`
> This is the check digit.

```{r}
get_check <- \(x) {
  ceiling(x / 10) * 10 - x
}

(xx <- get_check(xx))
```

> Append the check digit to the identifier: `1234567893`

```{r}
prefix_check <- \(pre, check) {
  paste0(pre, check)
}
prefix_check(123456789, xx)
```

::: 


# Constructor Goals {#sec-constructor}

I want to build a function that constructs a valid NPI from a 10-digit NPI "candidate." The function should print the validation steps to the console. 

If the input is syntactically valid, it should return the original NPI invisibly along with a `success!` message. If invalid, it should return the valid NPI with a `warning!` message.

There should also be a `verbose` option to silence the messages and return only the valid NPI. And finally, a minimal version that simply returns `TRUE` or `FALSE`.

## Validating the Input

```{r filename="input_validation.R"}
#| error: true
#| message: true

# Must be a character vector
check_is_character <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!rlang::is_character(x)) {
    cli::cli_abort(
      "An {.arg {arg}} must be a {.cls character} vector.", 
      arg = arg, 
      call = call
      )
  }
}

# Characters must all be numbers
check_characters_numeric <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_grepl(x, "^[[:digit:]]+$")) {
    cli::cli_abort(
      "An {.arg {arg}} must contain numbers only.", 
      arg = arg, 
      call = call
      )
  }
}

# Must have 10 characters
check_nchars_10 <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (stringfish::sf_nchar(x) != 10L) {
    cli::cli_abort(
      "An {.arg {arg}} must be 10 characters long.", 
      arg = arg, 
      call = call
      )
  }
}

# Must begin with 1 or 2
check_first_char <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_substr(x, 1, 1) %in% c("1", "2")) {
    cli::cli_abort(
      "An {.arg {arg}} must start with a 1 or 2.", 
      arg = arg, 
      call = call
      )
  }
}
```

## CLI Messages

```{r filename="cli_messages.R"}
npi_inform <- function(x, msg) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c(">" = glue::glue("{msg}: {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_inform"
  )
}

npi_warn <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c("x" = glue::glue("NPI is invalid: {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_warn"
  )
}

npi_suggest <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c("i" = glue::glue("Did you mean? {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_suggest"
  )
}

npi_success <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c("v" = glue::glue("NPI is valid: {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_success"
  )
}
```

## Constructor Function

```{r filename="npi_constructor.R"}
npi_constructor <- function(npi) {
  
  check_is_character(npi)
  check_characters_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  p       <- \(...) paste0(...)
  s       <- \(x) unlist(strsplit(x, ""), use.names = FALSE)
  
  npi_inform(
    npi, 
    "Testing NPI candidate")
  
  id      <- rev(s(npi)[1:9])
  
  npi_inform(
    p(id, collapse = ""), 
    "Reverse 9-digit identifier")
  
  idx     <- seq(1, length(id), 2)
  id      <- as.numeric(id)
  id[idx] <- as.numeric(id[idx]) * 2
  id[idx] <- ifelse(id[idx] > 9, id[idx] - 9, id[idx])
  
  npi_inform(
    p(id, collapse = " "), 
    "Double & reduce alternates")
  
  id      <- sum(id)
  cn      <- id + 24
  
  npi_inform(
    p(p(c(id, 24), collapse = " + "), p(" = ", cn)), 
    "Add 24 to sum digits")
  
  ml      <- ceiling(cn / 10) * 10
  
  npi_inform(
    p(p("⌈", cn, "⌉"), p(" = ", ml)),
    "Next multiple of 10")
  
  ck <- ml - cn
  
  npi_inform(
    p(p(c(ml, cn), collapse = " - "), p(" = ", ck)), 
    "Find check digit")
  
  test <- substr(npi, 1, 9)
  test <- p(test, ck)
  
  npi_inform(
    p(test, collapse = ""), 
    "Append check digit")
  
  if (identical(test, npi)) {
    npi_success(p(c(test, npi), collapse = " == "))
  }
  
  if (!identical(test, npi)) {
    npi_warn(p(c(test, npi), collapse = " != "))
    npi_suggest(p(test, collapse = ""))
  }
  invisible(test)
}
```

#### Testing the Validation Checkers

```{r}
#| error: true
#| message: true
npi_constructor(123456789)
npi_constructor("123456789")
npi_constructor("O123456789")
npi_constructor("0000000000")
```

#### Well Does it Work?

```{r}
#| error: true
#| message: true
npi_constructor("1234567891")
npi_constructor("1043477615")
npi_constructor("1000000000")
```







