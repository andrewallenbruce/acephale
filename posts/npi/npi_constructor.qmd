---
title: "NPIs & Luhn's Algorithm"
subtitle: "Step-by-step National Provider Identifier Validation with Luhn's Algorithm"
description: "Experimenting with the CMS standard for NPI validation."
format:
  html:
    reference-location: margin
    other-links:
      - text: Luhn Algorithm
        icon: bookmark-plus
        href: https://en.wikipedia.org/wiki/Luhn_algorithm
      - text: ISO/IEC 7812
        icon: bookmark-plus
        href: https://en.wikipedia.org/wiki/ISO/IEC_7812
      - text: CMS NPI Standard
        icon: bookmark-plus
        href: https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf
      - text: CMS-10114 NPI Application
        icon: bookmark-plus
        href: https://www.cms.gov/medicare/cms-forms/cms-forms/downloads/cms10114.pdf
editor_options: 
  chunk_output_type: console
---

```{r setup}
#| message: false
#| warning: false
#| echo: false
#| cache: false

knitr::opts_chunk$set(
  collapse  = FALSE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "",
  dpi       = 600, 
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)
options(scipen = 999)
library(tidyverse)
library(rlang)
library(cli)
```


A **National Provider Identifier (NPI)** is a unique 10-digit identification number assigned to health care providers in the United States through NPPES^[NPPES is the National Plan and Provider Enumeration System (NPPES) NPI Registry, a free directory of all active NPI records.] The Centers for Medicare & Medicaid Services (CMS) developed the NPI as a way to standardize the identification of health care providers across the health care industry.

# CMS NPI Standard {#sec-cmsstandard}

The following is an excerpt from the CMS document on the NPI check digit calculation, [Requirements for National Provider Identifier (NPI) and NPI Check Digit (2004-01-23)](https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf).

## NPI Requirements {#sec-requirements}
|                              |                                                                                     |
|------------------------------|-------------------------------------------------------------------------------------|
| {{< mi wrong_location >}}    | Must consist of **10** numeric digits, with the 10<sup>th</sup> as the check digit. |
| {{< mi explore_off >}}       | Have no embedded intelligence.                                                      |
| {{< mi lightbulb_circle >}}  | Begin with a `1` or `2`.^[Use of other first digits for the NPI must be coordinated with the use of first digits by the standard health plan identifier, when it is adopted.] |
| {{< mi pattern >}}           | Be generated by a scattering algorithm using all possible numeric combinations.     |
| {{< mi fingerprint >}}       | Be unique, without requiring database access for verification.                      |

## NPI Check Digit {#sec-checkdigit}

The check digit is calculated using the [Luhn formula](https://en.wikipedia.org/wiki/Luhn_algorithm) for computing the modulus 10 *double-add-double* check digit.^[This algorithm is recognized as an ISO standard (ISO/IEC 7812) and is the specified check digit algorithm to be used for the card issuer identifier on a standard health identification card.]

When an NPI is used as a card issuer identifier on a standard health identification card, it is prefixed with **80840**, in which **80** indicates *health applications* and **840** indicates the *United States*.
To enable this feature for any NPI, the check digit will always be calculated as if the prefix is present. For a non-prefixed NPI, this is accomplished by adding the constant **24** in step 2 of the calculation.

### Check Digit Calculation

The calculation is as follows:

   1. Beginning with the rightmost digit, double the value of the alternate digits.
   
   1. Add the individual digits of the products from Step 1 to the unaffected digits from the original number.
   
   1. Subtract the result of step 2 from the next highest number ending in zero. This is the check digit.


::: {#note-mod .callout-note}

### Next Multiple of Ten

The *next highest number ending in zero* is the next multiple of ten. 

Specifically, for some number $n$, the next multiple of ten would be $n + (10 - (n \mod 10))$:

```{r}
next_10 <- \(n) n + (10 - (n %% 10))
```

For example, if $n$ is `23`, the next multiple of ten is `30`:

```{r}
next_10(23)
```

If $n$ is a multiple of ten, such as `50`, the next multiple of 10 is `60`:

```{r}
next_10(50)
```


::: 

{{< pagebreak >}}

#### Examples

The following check digit calculation examples are reproduced from the CMS Standard document, which includes demonstrations for both prefixed and non-prefixed NPIs.

::: {.panel-tabset}

## Prefix

> Assume the prefixed 
> 9-position identifier 
> is `80840123456789`

```{r}
prefix_id <- \(x) {
  as.integer(
    unlist(
      strsplit(
        paste0(80840, x), "")
      )
    )
}

x <- prefix_id(123456789)

x
```

> Beginning on the right, 
> double the alternate digits: 
> `8 0 8 8 0 2 2 6 4 10 6 14 8 18`

```{r}
reverse_double <- \(x) {
  
  x <- rev(x)
  
  idx <- c(1, 3, 5, 7, 9)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

x <- reverse_double(x)

x
```

> Sum the *individual* digits: 
> `8 + 0 + 8 + 8 +` 
> `0 + 2 + 2 + 6 +` 
> `4 + 1 + 0 + 6 +`
> `1 + 4 + 8 + 1 +` 
> `8 = 67`


```{r}
add_digits <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    )
}

x <- add_digits(x)

x
```

> Subtract the sum from the next multiple of 10. 
> This is the check digit: `70 – 67 = 3`


```{r}
check_digit <- \(x) {
  ceiling(x / 10) * 10 - x
}

x <- check_digit(x)

x
```

> Append the check digit to the 
> identifier: `808401234567893`

```{r}
append_check <- \(id, check) {
  cat(
    paste0(
      paste0(
        prefix_id(id), 
        collapse = ""), 
      check)
    )
}

append_check(123456789, x)
```

## Non-Prefix

> Assume the non-prefixed 
> 9-position identifier 
> is `123456789`

```{r}
split_id <- \(x) {
  as.integer(
    unlist(
      strsplit(
        as.character(x), ""
        )
      )
    )
}

x <- split_id(123456789)

x
```

> Beginning on the right, 
> double the alternate digits:
> `2  2  6  4 10  6 14  8 18`

```{r}
reverse_double <- \(x) {
  
  x <- rev(x)
  
  idx <- c(1, 3, 5, 7, 9)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

x <- reverse_double(x)

x
```

> Add constant 24 to the sum of the individual digits: 
> `2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 + 24 = 67`


```{r}
sum_plus_24 <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    ) + 24
}

x <- sum_plus_24(x)

x
```

> Subtract the sum from the next multiple of 10. 
> This is the check digit: `70 – 67 = 3`

```{r}
check_digit <- \(x) {
  ceiling(x / 10) * 10 - x
}

x <- check_digit(x)

x
```

> Append the check digit to 
> the identifier: `1234567893`

```{r}
append_check <- \(id, check) {
  cat(
    paste0(
      id, 
      check
      )
    )
}

append_check(123456789, x)
```

::: 

{{< pagebreak >}}

# Function Goals {#sec-goals}

I want to build a function that constructs a valid NPI from a 10-digit NPI "candidate." The function should print the validation steps to the console. 
If the input is syntactically valid, it should return the original NPI invisibly along with a `success!` message. If invalid, it should return the valid NPI with a `warning!` message.

There should also be a `verbose` option to silence the messages and return only the valid NPI. And finally, a minimal version that simply returns `TRUE` or `FALSE`.


## Validating the Input
   
   * Input string (`x`) validation order:
      + Abort if not `length(x) == 1`
      + Abort if not 10 characters long
      + Abort if any elements of `x` are not `0-9`
      + Abort if first element is not `"1"` or `"2"`
      + Coerce to `<character>` if `x` is a `<numeric>` vector

```{r filename="input_validation.R"}
#| error: true
#| message: true
# Abort if `x` is `length(x) != 1`
check_length <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (length(x) != 1) {
    cli::cli_abort(
      "{.arg {arg}} must be of length 1.", 
      arg = arg, 
      call = call,
      class = "check_length"
      )
  }
}

# If `x` is a `<numeric>` 
# vector, coerce to `<character>`
numeric_to_char <- function(x) {
  if (!rlang::is_character(x)) { 
    as.character(x)
  } else {
    x  
  }
}

# Abort if any of `x`'s 
# elements are not numbers
check_chars_numeric <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_grepl(x, "^[[:digit:]]+$")) {
    cli::cli_abort(
      "An {.arg {arg}} must contain numbers only.", 
      arg = arg, 
      call = call,
      class = "check_chars_numeric"
      )
  }
}

# Abort if `x` is not 
# 10 characters long
check_nchars_10 <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (stringfish::sf_nchar(x) != 10L) {
    cli::cli_abort(
      "An {.arg {arg}} must be 10 characters long.", 
      arg = arg, 
      call = call,
      class = "check_nchars_10"
      )
  }
}

# Must begin with 1 or 2
check_first_char <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_substr(x, 1, 1) %in% c("1", "2")) {
    cli::cli_abort(
      "An {.arg {arg}} must start with a 1 or 2.", 
      arg = arg, 
      call = call,
      class = "check_first_char"
      )
  }
}
```

## CLI Messages

```{r filename="cli_messages.R"}
npi_inform <- function(x, msg) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c("*" = glue::glue("{msg}: {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_inform"
  )
}

npi_alert_invalid <- function(x, y) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (c("x" = "NPI is invalid")),
    body = (c("!" = glue::glue("{x} != {y}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_alert_invalid"
  )
}

npi_alert_valid <- function(x, y) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (c("v" = "NPI is valid")),
    body = (c(">" = glue::glue("{x} == {y}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call,
    class = "npi_alert_valid"
  )
}
```

## Constructor Function

```{r filename="npi_constructor.R"}
npi_constructor <- function(npi, verbose = TRUE) {
  
  npi <- numeric_to_char(npi)
  check_length(npi)
  check_chars_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  p <- \(...) paste0(...)
  s <- \(x) unlist(strsplit(x, ""), use.names = FALSE)
  
  id <- rev(s(npi)[1:9])
  
  if (verbose) {
    npi_inform(npi, "Testing NPI candidate")
    npi_inform(p(id, collapse = ""), "Reverse 9-digit identifier")
  }
  
  idx     <- c(1, 3, 5, 7, 9)
  id      <- as.numeric(id)
  id[idx] <- as.numeric(id[idx]) * 2
  id[idx] <- ifelse(id[idx] > 9, id[idx] - 9, id[idx])
  
  if (verbose) {
    npi_inform(p(id, collapse = " "), "Double & reduce alternates")
  }
  
  id   <- sum(id)
  cn   <- id + 24
  ml   <- ceiling(cn / 10) * 10
  ck   <- ml - cn
  test <- substr(npi, 1, 9)
  test <- p(test, ck)
  
  if (verbose) {
    
    npi_inform(p(p(c(id, 24), collapse = " + "), p(" = ", cn)), "Add 24 to sum digits")
    npi_inform(p(p("⌈", cn, "⌉"), p(" = ", ml)) ,"Next multiple of 10")
    npi_inform(p(p(c(ml, cn), collapse = " - "), p(" = ", ck)), "Find check digit")
    npi_inform(p(test, collapse = ""), "Append check digit")
    
    if (identical(test, npi)) npi_alert_valid(test, npi)
    if (!identical(test, npi)) npi_alert_invalid(test, npi)
  }
  invisible(test)
}
```

#### Test Validations

```{r}
#| error: true
#| message: true
#| warning: true
npi_constructor("123456789")
npi_constructor("O123456789")
npi_constructor("0000000000")
```

#### Test Verbose Output

```{r}
#| error: true
#| message: true
#| warning: true
npi_constructor(1234567891)
```

```{r}
#| error: true
#| message: true
#| warning: true
npi_constructor(1043477615)
```

```{r}
#| error: true
#| message: true
#| warning: true
npi_constructor(1000000000)
```

#### Test Verbose Option/Invisible Return

```{r}
#| error: true
#| message: true
#| warning: true
npi_constructor(1000000000, verbose = FALSE)

new_npi <- npi_constructor(1000000000, verbose = FALSE)

new_npi
```

{{< pagebreak >}}

## Minimal Validator

```{r filename="is_valid_npi.R"}
is_valid_npi <- function(npi) {
  
  npi <- numeric_to_char(npi)
  check_length(npi)
  check_chars_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  p  <- \(...) paste0(...)
  s  <- \(x) unlist(strsplit(x, ""), use.names = FALSE)
  ix <- c(1, 3, 5, 7, 9)
  
  id     <- as.numeric(rev(s(npi)[1:9]))
  id[ix] <- id[ix] * 2
  id[ix] <- ifelse(id[ix] > 9, id[ix] - 9, id[ix])
  
  id   <- sum(id) + 24
  ck   <- (ceiling(id / 10) * 10) - id
  test <- p(substr(npi, 1, 9), ck)
  
  identical(test, npi)
}
```

#### Test Validator

```{r}
#| error: true
#| message: true
#| warning: true
is_valid_npi(123456789)
is_valid_npi("O123456789")
is_valid_npi(0000000000) # All leading zeroes will be dropped
is_valid_npi(3000000000)
is_valid_npi(1043477615)
is_valid_npi(1234567891)
```

```{r}
random_npi_generator <- \(n) {
  replicate(
    n = n, 
    expr = paste0(
      c(sample(1:2, 1, replace = TRUE), 
        sample(0:9, 9, replace = TRUE)), 
      collapse = ""))
}

random_npi_generator(3)
```

```{r}
n <- 100000
x <- random_npi_generator(n)
y <- x[collapse::whichv(purrr::map_lgl(x, is_valid_npi), TRUE)]

paste0((length(y) / n) * 100, "%")

bench::mark(
  purrr::map_lgl(x, is_valid_npi)) |> 
  dplyr::glimpse()
```

{{< pagebreak >}}


# Session Information

```{r}
#| label: sessioninfo
#| echo: false
#| eval: true
sessioninfo::session_info(pkgs = "loaded", info = "packages")
```

