---
title: "Building an NPI Constructor"
subtitle: "Validating National Provider Identifiers with Luhn's Algorithm"
description: "A guide to National Provider Identifiers and the CMS standard for NPI validation."
format:
  html:
    reference-location: block
    other-links:
      - text: Luhn Algorithm
        icon: bookmark-plus
        href: https://en.wikipedia.org/wiki/Luhn_algorithm
      - text: CMS NPI Standard
        icon: bookmark-plus
        href: https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf
      - text: CMS-10114 NPI Application
        icon: bookmark-plus
        href: https://www.cms.gov/medicare/cms-forms/cms-forms/downloads/cms10114.pdf
    mermaid:
      theme: default
---

```{r setup}
#| message: false
#| warning: false
#| echo: false
#| cache: false

knitr::opts_chunk$set(
  comment   = "",
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)

library(tidyverse)
library(downlit)
library(gt)
library(provider)
library(rlang)
library(cli)

p <- function(...) {paste0(...)}
```


# Introduction {#sec-introduction}

The National Provider Identifier (NPI) is a unique 10-digit identification number assigned to health care providers in the United States through NPPES. The Centers for Medicare & Medicaid Services (CMS) developed the NPI as a way to standardize the identification of health care providers across the health care industry. [NPPES](https://npiregistry.cms.hhs.gov/search) is the National Plan and Provider Enumeration System (NPPES) NPI Registry, a free directory of all active NPI records.

# The CMS Standard for NPI Validation {#sec-cmsstandard}

The following is an excerpt from the CMS document on the NPI check digit calculation, [Requirements for National Provider Identifier (NPI) and NPI Check Digit (2004-01-23)](https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf).

## Requirements for the NPI {#sec-requirements}
   
   * Consist of 10 numeric digits. The 10<sup>th</sup> digit is the check digit.
   
   * Have no embedded intelligence.
   
   * Begin with a `1` or `2`.
[Use of other first digits for the NPI must be coordinated with the use of first digits by the standard health plan identifier, when it is adopted.]{.aside}
   
   * Generated by a scattering algorithm using all possible numeric combinations.
   
   * Be unique, without requiring database access for verification.

## Requirements for the NPI Check Digit {#sec-checkdigit}

   * Calculated using the Luhn formula for computing the modulus 10 “double-add-double” check digit. 
[This algorithm is recognized as an ISO standard and is the specified check digit algorithm to be used for the card issuer identifier on a standard health identification card.]{.aside}

### Prefix 80840

When an NPI is used as a card issuer identifier on a standard health identification card, it is preceded by the prefix **80840**, in which **80** indicates *health applications* and **840** indicates the *United States*.

To enable this feature for any NPI, the check digit will always be calculated as if the prefix is present. 

For a non-prefixed NPI, this is accomplished by adding the constant **24** in step 2 of the check digit calculation.

## Luhn Formula for Modulus 10 "double-add-double" Check Digit

The Luhn check digit formula is calculated as follows:

   1. Double the value of alternate digits, beginning with the rightmost digit.
   
   1. Add the individual digits of the products resulting from step 1 to the unaffected digits from the original number.
   
   1. Subtract the total obtained in step 2 from the next highest number ending in zero. This is the check digit. If the total obtained in step 2 is a number ending in zero, the check digit is zero.

<br>

::: {#note-mod .callout-note}

### Multiples of Ten

The *next highest number ending in zero* is simply the next multiple of ten. 

Specifically, for some number $n$, the next multiple of ten would be $n + (10 - (n \mod 10))$ if $n$ is not already a multiple of ten. 

For example, if $n$ is `23`, the next multiple of ten `30`. If $n$ is a multiple of ten, such as `50`, the next multiple of 10 is `60`.

::: 

<br>

### Check Digit Calculation Examples

::: {.panel-tabset}

## With Prefix

> Assume the 9-position identifier part of the NPI is `123456789`:

```{r}
identifier <- 123456789

identifier
```


> If used as a card issuer identifier on a standard health identification card the full number is `80840123456789`:

```{r}
prefix <- 80840

prefixed <- paste0(prefix, identifier)

prefixed
```


> Card issuer identifier without check digit: `8 0 8 4 0 1 2 3 4 5 6 7 8 9`

```{r}
id_split <- unlist(strsplit(prefixed, ""), use.names = FALSE)

id_split
```


> **Step 1:** Double the value of alternate digits, beginning with the rightmost digit: `0 8 2 6 10 14 18`

```{r}
# Reverse order of digits
reversed <- rev(id_split)

# Select index of every other digit
idx_even <- seq(1, length(id_split), 2)

# Double the value of the alternate digits
reversed[idx_even] <- as.numeric(reversed[idx_even]) * 2

# Reverse the order back
original <- rev(reversed)

original
```


> **Step 2:** Add the individual digits of products of doubling, plus unaffected digits: 
> `8 + 0 + 8 + 8 + 0 + 2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67`


```{r}
# Split and unlist to separate digits
resplit <- unlist(strsplit(original, ""), use.names = FALSE)

# Add constant 24 to the sum of the digits
added <- sum(as.numeric(resplit))

added
```


> **Step 3:** Subtract from next higher number ending in zero: `70 – 67 = 3`


```{r}
# Find the next highest multiple of 10
mod10 <- ceiling(added / 10) * 10

# Subtract the sum from the next highest multiple of 10
check <- mod10 - added

check
```

> Therefore, the check digit is `3`

```{r}
paste0(prefixed, check)
```

> and the card issuer identifier with the check digit appended is `808401234567893`.


## Without Prefix

Assume the 9-position identifier part of the NPI is 123456789. Using the Luhn formula on the identifier portion, the check digit is calculated as follows: 

NPI without check digit:
1 2 3 4 5 6 7 8 9

Step 1: Double the value of alternate digits, beginning with the rightmost digit.
2 6 10 14 18

Step 2: Add constant 24, to account for the 80840 prefix that would be present on a card issuer identifier, plus the individual digits of products of doubling, plus unaffected digits.
24 + 2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67

Step 3: Subtract from next higher number ending in zero.
70 – 67 = 3

Check digit = 3

NPI with check digit = 1234567893 

::: 


# NPI Constructor {#sec-constructor}

## Input Validation

```{r filename="input_validation.R"}
# Must be a character vector as R drops leading zeros
# ---This won't be needed if NPIs must start with a 1 or 2
check_is_character <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (any(!rlang::is_character(x))) {
    cli::cli_abort(
      "{.arg {arg}} must be a {.cls character} vector.", 
      arg = arg, 
      call = call)
  }
}

# Characters must all be numbers
check_characters_numeric <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (any(!stringfish::sf_grepl(x, "^[[:digit:]]+$"), na.rm = TRUE)) {
    cli::cli_abort(
      "{.arg {arg}} must contain numbers only.", 
      arg = arg, 
      call = call)
  }
}

# Must have 10 characters
check_nchars_10 <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (any(stringfish::sf_nchar(x) != 10L)) {
    cli::cli_abort(
      "{.arg {arg}} must be 10 characters long.", 
      arg = arg, 
      call = call)
  }
}

x <- "123456789"

# Must begin with 1 or 2
check_first_char <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (any(!stringfish::sf_substr(x, 1, 1) %in% c("1", "2"))) {
    cli::cli_abort(
      "{.arg {arg}} must start with 1 or 2.", 
      arg = arg, 
      call = call)
  }
}
```

## First Draft

```{r filename="construct_npi_1.R"}
construct_npi_1 <- function(npi) {
  
  check_is_character(npi)
  check_characters_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  npi_test <- npi
  
  # Remove the 10th digit to create the 9-position identifier part of the NPI
  id <- unlist(strsplit(npi_test, ""), use.names = FALSE)[1:9]
  
  #---
  id_print <- rlang::sym(paste0(c(id, "_"), collapse = ""))
  cli::cli_alert("01. Keep first 9 digits: {.strong {.val {id_print}}}")
  #---
  
  # Reverse order of digits
  x <- rev(id)
  
  #---
  rev_print <- rlang::sym(paste0(x, collapse = ""))
  cli::cli_alert("02. Reverse order of digits:  {.strong {.val {rev_print}}}")
  #---
  
  # Select index of every other digit
  idx <- seq(1, length(x), 2)
  
  #---
  idx_print <- rlang::sym(paste0(x[idx], collapse = " "))
  cli::cli_alert("03. Select every other digit: {.strong {.val {idx_print}}}")
  #---
  
  # Double the value of the alternate digits
  x[idx] <- as.numeric(x[idx]) * 2
  
  #---
  dbl_print <- rlang::sym(paste0(x[idx], collapse = " "))
  cli::cli_alert("04. Double each alternate digit: {.strong {.val {dbl_print}}}")
  ins_print <- rlang::sym(paste0(x, collapse = " "))
  cli::cli_alert("05. Insert alternates back into original string: {.strong {.val {ins_print}}}")
  #---
  
  # Reverse order of digits again
  x <- rev(x)
  
  #---
  rev2 <- x
  rev2_print <- rlang::sym(paste0(x, collapse = " "))
  cli::cli_alert("06. Reverse order again: {.strong {.val {rev2_print}}}")
  #---
  
  
  # Split and unlist to separate digits
  x <- unlist(strsplit(x, ""), use.names = FALSE)
  
  #---
  rev2 <- unlist(strsplit(rev2, ""), use.names = FALSE)
  add <- sum(as.numeric(x))
  add_print <- rlang::sym(paste0(paste0(rev2, collapse = " + "), paste0(" = ", add)))
  cli::cli_alert("07. Sum the individual digits: {.strong {.val {add_print}}}")
  #---
  
  # Add constant 24 to the sum of the digits
  x <- sum(as.numeric(x)) + 24
  
  #---
  const_print <- rlang::sym(paste0(paste0(c(add, 24), collapse = " + "), paste0(" = ", add + 24)))
  cli::cli_alert("08. Add {.emph constant} {.strong 24} to the sum: {.strong {.val {const_print}}}")
  #---
  
  # Find the next higher number ending in zero
  y <- ceiling(x / 10) * 10
  
  #---
  int_print <- rlang::sym(paste0(paste0("⌈", add + 24,"⌉"), paste0(" = ", y)))
  cli::cli_alert("09. Find next largest integer divisible by 10: {.strong {.val {int_print}}}")
  #---
  
  # Find the check digit by subtracting x from y
  z <- y - x
  
  #---
  check_print <- rlang::sym(paste0(paste0(c(y, (add + 24)), collapse = " - "), paste0(" = ", z)))
  cli::cli_alert(c("10. Find the check digit by subtracting {.emph step 08} from {.emph step 09}: 
{.strong {.val {check_print}}}"))
  #---
  
  # Append the check digit to the end of the 9-digit identifier
  id[10] <- z
  
  #---
  append_print <- rlang::sym(paste0(id, collapse = ""))
  cli::cli_alert(c("11. Append the check digit to the number from step 01: {.strong {.val {append_print}}}"))
  #---
  
  # Collapse the vector into a single string
  npi_valid <- paste0(id, collapse = "")
  
  # Is the syntactically valid NPI identical to the test NPI?
  if (identical(npi_valid, npi_test)) {
    
    #---
    identical <- rlang::sym(paste0(c(npi_test, npi_valid), collapse = " = "))
    cli::cli_alert_success(c("NPI {.strong is} syntactically valid: {.strong {.val {identical}}}"))
    #---
  }
  
  if (!identical(npi_valid, npi_test)) {
    
    #---
    not_identical <- rlang::sym(paste0(c(npi_test, npi_valid), collapse = " != "))
    cli::cli_alert_danger(c("NPI {.strong is not} syntactically valid: {.strong {.val {not_identical}}}"))
    #---
  }
}
```

### Testing Validation

```{r}
#| error: true
construct_npi_1(123456789)
construct_npi_1("123456789")
construct_npi_1("O123456789")
construct_npi_1("0000000000")
```

### Does it Work?

```{r}
construct_npi_1("1234567891")
construct_npi_1("1043477615")
construct_npi_1("1000000000")
```


## Second Draft

```{r}
cli_npi <- npi_test <- "1234567891"


npi_msg <- function(x, msg) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (
      c(">" = glue::glue_col("{msg}:"), 
        " " = glue::glue_col("     {blue {x}}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call
  )
}

npi_msg(x = npi_test, "Testing NPI")
```



```{r filename="construct_npi_2.R"}
construct_npi_2 <- function(npi) {
  
  check_is_character(npi)
  check_characters_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  npi_test <- npi
  
  npi_msg(npi_test, "Testing NPI")
  
  # Remove the 10th digit to create the 9-position identifier part of the NPI
  id_9 <- unlist(strsplit(npi_test, ""), use.names = FALSE)[1:9]
  
  npi_msg(paste0(id_9, collapse = ""), "Remove 10th digit")
  
  # Reverse order of digits
  x_rev <- rev(id_9)
  
  npi_msg(paste0(x_rev, collapse = ""), "Reverse order")
  
  # Select index of every other digit
  x_idx <- seq(1, length(x_rev), 2)
  
  npi_msg(paste0(x_rev[x_idx], collapse = " "), "Select every other digit")
  
  # Double the value of the alternate digits
  x_rev[x_idx] <- as.numeric(x_rev[x_idx]) * 2
  
  npi_msg(paste0(x_rev[x_idx], collapse = " "), "Double each")
  npi_msg(paste0(x_rev, collapse = " "), "Replace original with doubles")
  
  # Split and unlist to separate digits
  x_split <- unlist(strsplit(x_rev, ""), use.names = FALSE)
  x_add <- sum(as.numeric(x_split))
  
  npi_msg(paste0(paste0(x_split, collapse = " + "), paste0(" = ", x_add)), "Sum individual digits")

  # Add constant 24 to the sum of the digits
  x_24 <- x_add + 24
  
  npi_msg(paste0(paste0(c(x_add, 24), collapse = " + "), paste0(" = ", x_24)), "Add 24 to the sum")
  
  x_divide <- x_24 / 10
  npi_msg(paste0(paste0(x_24, " / ", 10), paste0(" = ", x_divide)), "Divide by 10")
  
  x_divide_first <- as.numeric(unlist(strsplit(as.character(x_divide), ""), use.names = FALSE)[1])
  npi_msg(paste0(paste0(x_divide), paste0(" = ", x_divide_first)), "Take first digit")
  
  x_plus_one <- x_divide_first + 1
  npi_msg(paste0(paste0(x_divide_first, " + ", 1), paste0(" = ", x_plus_one)), "Add one")
  
  x_paste_zero <- paste0(x_plus_one, "0")
  npi_msg(paste0(paste0(x_plus_one, " * ", 10), paste0(" = ", x_paste_zero)), "Multiply by 10")
  
  # Find the next higher number ending in zero
  x_next <- ceiling(x_24 / 10) * 10
  npi_msg(paste0(paste0("⌈", x_24,"⌉"), paste0(" = " , x_next)), "Next multiple of 10")
  
  # Find the check digit by subtracting x from y
  x_check <- x_next - x_24
  npi_msg(paste0(paste0(c(x_next, x_24), collapse = " - "), paste0(" = ", x_check)), "Find the check digit")
  
  # Append the check digit to the end of the 9-digit identifier
  id_10 <- id_9
  id_10[10] <- x_check
  
  npi_msg(paste0(id_10, collapse = ""), "Append check digit")
  
  # Collapse the vector into a single string
  npi_valid <- paste0(id_10, collapse = "")
  
  # Is the syntactically valid NPI identical to the test NPI?
  if (identical(npi_valid, npi_test)) {
    npi_msg(paste0(c(npi_test, npi_valid), collapse = " == "), "NPI is syntactically valid")
  }
  
  if (!identical(npi_valid, npi_test)) {
    npi_msg(paste0(c(npi_test, npi_valid), collapse = " != "), "NPI is not syntactically valid")
  }
  invisible(npi_valid)
}
```


### Testing Validation

```{r}
#| error: true
construct_npi_2(123456789)
construct_npi_2("123456789")
construct_npi_2("O123456789")
construct_npi_2("0000000000")
```

### Does it Work?

```{r}
construct_npi_2("1234567891")
construct_npi_2("1043477615")
construct_npi_2("1000000000")
```




```{r}
x <- "1234567891"
x <- "1043477615"

base_npi <- function(x) {
  
  xa <- xb <- as.integer(unlist(strsplit(x, ""), use.names = FALSE)[1:9])
  
  x <- rev(xb)
  
  even <- x[seq(1, length(x), 2)] * 2
  odd  <- x[seq(2, length(x), 2)]
  
  even_less <- even[which(even < 9)]
  even_more <- as.integer(unlist(strsplit(as.character(even[which(even > 9)]), ""), use.names = FALSE))
  
  sumup <- sum(odd) + sum(even_less) + sum(even_more) + 24
  
  xb[10] <- (ceiling(sumup / 10) * 10) - sumup
  
  identical(as.integer(paste0(xb, collapse = "")), xa)
}

# base_npi("1043477615")
```



```{r}
x <- "1234567891"
x <- "1043477615"

luhn <- function(x) {
  
  xa <- x
  
  x <- rev(
    as.integer(
      unlist(
        strsplit(x, ""), use.names = FALSE)[1:9]
      )
    )
  
  idx_odd  <- seq_along(x) %% 2 == 1
  idx_even <- seq_along(x) %% 2 == 0
  
  x[idx_even] <- x[idx_even] * 2
  x[idx_even] <- ifelse(x[idx_even] > 9, x[idx_even] - 9, x[idx_even])
  
  sumx <- collapse::fsum(c(x[idx_odd], x[idx_even], 24))
  x <- rev(x)
  x[10] <- (ceiling(sumx / 10) * 10) - sumx
  x
  
  # sum_x %% 10 == 0
}
```


```{r}
# luhn("123456789")
# luhn("104347761")
```

