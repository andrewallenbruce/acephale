---
title: "Building an NPI Constructor"
subtitle: "Validating National Provider Identifiers with Luhn's Algorithm"
description: "A guide to National Provider Identifiers and the CMS standard for NPI validation."
format:
  html:
    reference-location: block
    other-links:
      - text: Luhn Algorithm
        icon: bookmark-plus
        href: https://en.wikipedia.org/wiki/Luhn_algorithm
      - text: CMS NPI Standard
        icon: bookmark-plus
        href: https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf
      - text: CMS-10114 NPI Application
        icon: bookmark-plus
        href: https://www.cms.gov/medicare/cms-forms/cms-forms/downloads/cms10114.pdf
---

```{r setup}
#| message: false
#| warning: false
#| echo: false
#| cache: false

knitr::opts_chunk$set(
  comment   = "",
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)

library(tidyverse)
library(downlit)
library(gt)
library(provider)
library(rlang)
library(cli)

p <- function(...) {paste0(...)}
```


The National Provider Identifier (NPI) is a unique 10-digit identification number assigned to health care providers in the United States through NPPES. The Centers for Medicare & Medicaid Services (CMS) developed the NPI as a way to standardize the identification of health care providers across the health care industry. [NPPES](https://npiregistry.cms.hhs.gov/search) is the National Plan and Provider Enumeration System (NPPES) NPI Registry, a free directory of all active NPI records.

# CMS NPI Standard {#sec-cmsstandard}

The following is an excerpt from the CMS document on the NPI check digit calculation, [Requirements for National Provider Identifier (NPI) and NPI Check Digit (2004-01-23)](https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf).

## NPI Requirements {#sec-requirements}
   
   * Consist of 10 numeric digits. The 10<sup>th</sup> digit is the check digit.
   
   * Have no embedded intelligence.
   
   * Begin with a `1` or `2`.
[Use of other first digits for the NPI must be coordinated with the use of first digits by the standard health plan identifier, when it is adopted.]{.aside}
   
   * Generated by a scattering algorithm using all possible numeric combinations.
   
   * Be unique, without requiring database access for verification.

## NPI Check Digit {#sec-checkdigit}

The check digit is calculated using the Luhn formula for computing the modulus 10 “double-add-double” check digit. [This algorithm is recognized as an ISO standard and is the specified check digit algorithm to be used for the card issuer identifier on a standard health identification card.]{.aside}

When an NPI is used as a card issuer identifier on a standard health identification card, it is preceded by the prefix **80840**, in which **80** indicates *health applications* and **840** indicates the *United States*.

To enable this feature for any NPI, the check digit will always be calculated as if the prefix is present. 

For a non-prefixed NPI, this is accomplished by adding the constant **24** in step 2 of the check digit calculation.

## Check Digit Calculation

The check digit formula (Luhn Modulus 10 "double-add-double") is calculated as follows:

   1. Beginning with the rightmost digit, double the value of the alternate digits.
   
   1. Add the individual digits of the products from Step 1 to the unaffected digits from the original number.
   
   1. Subtract the result of step 2 from the next highest number ending in zero. This is the check digit.


::: {#note-mod .callout-note}

### Multiples of Ten

The *next highest number ending in zero* is simply the next multiple of ten. 

Specifically, for some number $n$, the next multiple of ten would be $n + (10 - (n \mod 10))$ if $n$ is not already a multiple of ten. 

```{r}
next_mult_10 <- \(n) n + (10 - (n %% 10))
```

For example, if $n$ is `23`, the next multiple of ten is `30`:

```{r}
next_mult_10(23)
```

If $n$ is a multiple of ten, such as `50`, the next multiple of 10 is `60`:

```{r}
next_mult_10(50)
```


::: 

<br>

### Check Digit Calculation Examples

::: {.panel-tabset}

## With Prefix

> Assume the prefixed 9-position identifier is `80840123456789`:

```{r}
make_identifier <- \(x, y) {
  as.integer(
    unlist(
      strsplit(
        paste0(x, y), 
        "")
    )
  )
}

(x <- make_identifier(80840, 123456789))
```

> Beginning on the right, double the alternate digits:
>
> `8 0 8 8 0 2 2 6 4 10 6 14 8 18`

```{r}
double_alternates <- \(x) {
  x <- rev(x)
  
  idx <- seq(1, length(x), 2)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

(x <- double_alternates(x))
```

> Add the individual digits of products of doubling, plus unaffected digits: 
> 
> `8 + 0 + 8 + 8 + 0 + 2 + 2 + 6 +` 
> `4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67`


```{r}
sum_individual_digits <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    )
}

(x <- sum_individual_digits(x))
```

> Subtract result from the next multiple of 10: `70 – 67 = 3`
> This is the check digit.


```{r}
get_check_digit <- \(x) {
  ceiling(x / 10) * 10 - x
}

(x <- get_check_digit(x))
```

> Append the check digit to the the card issuer identifier: `808401234567893`

```{r}
paste0(80840123456789, x)
```


## Without Prefix

> Assume the 9-position identifier is `123456789`

```{r}
make_id <- \(x) {
  as.integer(unlist(strsplit(as.character(x), "")))
}

(xx <- make_id(123456789))
```

> Beginning on the right, double the alternate digits:
> `2 4 6 9 10 14 18`
> `2  2  6  4 10  6 14  8 18`

```{r}
double_alts <- \(x) {
  x <- rev(x)
  
  idx <- seq(1, length(x), 2)
  
  x[idx] <- x[idx] * 2
  
  rev(x)
}

(xx <- double_alternates(xx))
```

> Add constant 24 to the sum of the individual digits: 
> `24 + 2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 = 67`


```{r}
sum_digits_constant <- \(x) {
  sum(
    as.integer(
      unlist(
        strsplit(
          as.character(x), "")
        )
      )
    ) + 24
}

(xx <- sum_digits_constant(xx))
```

> Subtract result from the next multiple of 10: `70 – 67 = 3`
> This is the check digit.

```{r}
(xx <- get_check_digit(xx))
```

> Append the check digit to the identifier: `1234567893`

```{r}
paste0(123456789, xx)
```

::: 


# NPI Constructor {#sec-constructor}

## Input Validation

```{r filename="input_validation.R"}
# Must be a character vector
check_is_character <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!rlang::is_character(x)) {
    cli::cli_abort(
      "An {.arg {arg}} must be a {.cls character} vector.", 
      arg = arg, 
      call = call)
  }
}

# Characters must all be numbers
check_characters_numeric <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_grepl(x, "^[[:digit:]]+$")) {
    cli::cli_abort(
      "An {.arg {arg}} must contain numbers only.", 
      arg = arg, 
      call = call)
  }
}

# Must have 10 characters
check_nchars_10 <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (stringfish::sf_nchar(x) != 10L) {
    cli::cli_abort(
      "An {.arg {arg}} must be 10 characters long.", 
      arg = arg, 
      call = call)
  }
}

x <- "123456789"

# Must begin with 1 or 2
check_first_char <- function(x) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  if (!stringfish::sf_substr(x, 1, 1) %in% c("1", "2")) {
    cli::cli_abort(
      "An {.arg {arg}} must start with a 1 or 2.", 
      arg = arg, 
      call = call)
  }
}
```

## First Draft

```{r filename="construct_npi_1.R"}
construct_npi_1 <- function(npi) {
  
  check_is_character(npi)
  check_characters_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  npi_test <- npi
  
  # Remove the 10th digit to create the 9-position identifier part of the NPI
  id <- unlist(strsplit(npi_test, ""), use.names = FALSE)[1:9]
  
  #---
  id_print <- rlang::sym(paste0(c(id, "_"), collapse = ""))
  cli::cli_alert("01. Keep first 9 digits: {.strong {.val {id_print}}}")
  #---
  
  # Reverse order of digits
  x <- rev(id)
  
  #---
  rev_print <- rlang::sym(paste0(x, collapse = ""))
  cli::cli_alert("02. Reverse order of digits:  {.strong {.val {rev_print}}}")
  #---
  
  # Select index of every other digit
  idx <- seq(1, length(x), 2)
  
  #---
  idx_print <- rlang::sym(paste0(x[idx], collapse = " "))
  cli::cli_alert("03. Select every other digit: {.strong {.val {idx_print}}}")
  #---
  
  # Double the value of the alternate digits
  x[idx] <- as.numeric(x[idx]) * 2
  
  #---
  dbl_print <- rlang::sym(paste0(x[idx], collapse = " "))
  cli::cli_alert("04. Double each alternate digit: {.strong {.val {dbl_print}}}")
  ins_print <- rlang::sym(paste0(x, collapse = " "))
  cli::cli_alert("05. Insert alternates back into original string: {.strong {.val {ins_print}}}")
  #---
  
  # Reverse order of digits again
  x <- rev(x)
  
  #---
  rev2 <- x
  rev2_print <- rlang::sym(paste0(x, collapse = " "))
  cli::cli_alert("06. Reverse order again: {.strong {.val {rev2_print}}}")
  #---
  
  
  # Split and unlist to separate digits
  x <- unlist(strsplit(x, ""), use.names = FALSE)
  
  #---
  rev2 <- unlist(strsplit(rev2, ""), use.names = FALSE)
  add <- sum(as.numeric(x))
  add_print <- rlang::sym(paste0(paste0(rev2, collapse = " + "), paste0(" = ", add)))
  cli::cli_alert("07. Sum the individual digits: {.strong {.val {add_print}}}")
  #---
  
  # Add constant 24 to the sum of the digits
  x <- sum(as.numeric(x)) + 24
  
  #---
  const_print <- rlang::sym(paste0(paste0(c(add, 24), collapse = " + "), paste0(" = ", add + 24)))
  cli::cli_alert("08. Add {.emph constant} {.strong 24} to the sum: {.strong {.val {const_print}}}")
  #---
  
  # Find the next higher number ending in zero
  y <- ceiling(x / 10) * 10
  
  #---
  int_print <- rlang::sym(paste0(paste0("⌈", add + 24,"⌉"), paste0(" = ", y)))
  cli::cli_alert("09. Find next largest integer divisible by 10: {.strong {.val {int_print}}}")
  #---
  
  # Find the check digit by subtracting x from y
  z <- y - x
  
  #---
  check_print <- rlang::sym(paste0(paste0(c(y, (add + 24)), collapse = " - "), paste0(" = ", z)))
  cli::cli_alert(c("10. Find the check digit by subtracting {.emph step 08} from {.emph step 09}: 
{.strong {.val {check_print}}}"))
  #---
  
  # Append the check digit to the end of the 9-digit identifier
  id[10] <- z
  
  #---
  append_print <- rlang::sym(paste0(id, collapse = ""))
  cli::cli_alert(c("11. Append the check digit to the number from step 01: {.strong {.val {append_print}}}"))
  #---
  
  # Collapse the vector into a single string
  npi_valid <- paste0(id, collapse = "")
  
  # Is the syntactically valid NPI identical to the test NPI?
  if (identical(npi_valid, npi_test)) {
    
    #---
    identical <- rlang::sym(paste0(c(npi_test, npi_valid), collapse = " = "))
    cli::cli_alert_success(c("NPI {.strong is} syntactically valid: {.strong {.val {identical}}}"))
    #---
  }
  
  if (!identical(npi_valid, npi_test)) {
    
    #---
    not_identical <- rlang::sym(paste0(c(npi_test, npi_valid), collapse = " != "))
    cli::cli_alert_danger(c("NPI {.strong is not} syntactically valid: {.strong {.val {not_identical}}}"))
    #---
  }
}
```

### Testing Validation

```{r}
#| error: true
construct_npi_1(123456789)
construct_npi_1("123456789")
construct_npi_1("O123456789")
construct_npi_1("0000000000")
```

### Does it Work?

```{r}
construct_npi_1("1234567891")
construct_npi_1("1043477615")
construct_npi_1("1000000000")
```


## Second Draft

```{r filename="npi_msg.R"}
npi_msg <- function(x, msg) {
  
  arg  <- rlang::caller_arg(x)
  call <- rlang::caller_env()
  
  rlang::inform(
    message = (c(">" = glue::glue("{msg}:     {x}"))),
    use_cli_format = TRUE,
    arg = arg,
    call = call
  )
}

npi_test <- "1234567891"
npi_msg(x = npi_test, "Testing NPI")
```



```{r filename="construct_npi_2.R"}
construct_npi_2 <- function(npi) {
  
  check_is_character(npi)
  check_characters_numeric(npi)
  check_nchars_10(npi)
  check_first_char(npi)
  
  npi_test <- npi
  
  npi_msg(npi_test, "Testing NPI")
  
  # Remove the 10th digit to create the 9-position identifier part of the NPI
  id_9 <- unlist(strsplit(npi_test, ""), use.names = FALSE)[1:9]
  
  npi_msg(paste0(id_9, collapse = ""), "Remove 10th digit")
  
  # Reverse order of digits
  x_rev <- rev(id_9)
  
  npi_msg(paste0(x_rev, collapse = ""), "Reverse order")
  
  # Select index of every other digit
  x_idx <- seq(1, length(x_rev), 2)
  
  npi_msg(paste0(x_rev[x_idx], collapse = " "), "Select every other digit")
  
  # Double the value of the alternate digits
  x_rev[x_idx] <- as.numeric(x_rev[x_idx]) * 2
  
  npi_msg(paste0(x_rev[x_idx], collapse = " "), "Double each")
  npi_msg(paste0(x_rev, collapse = " "), "Replace original with doubles")
  
  # Split and unlist to separate digits
  x_split <- unlist(strsplit(x_rev, ""), use.names = FALSE)
  x_add <- sum(as.numeric(x_split))
  
  npi_msg(paste0(paste0(x_split, collapse = " + "), paste0(" = ", x_add)), "Sum individual digits")

  # Add constant 24 to the sum of the digits
  x_24 <- x_add + 24
  
  npi_msg(paste0(paste0(c(x_add, 24), collapse = " + "), paste0(" = ", x_24)), "Add 24 to the sum")
  
  x_divide <- x_24 / 10
  npi_msg(paste0(paste0(x_24, " / ", 10), paste0(" = ", x_divide)), "Divide by 10")
  
  x_divide_first <- as.numeric(unlist(strsplit(as.character(x_divide), ""), use.names = FALSE)[1])
  npi_msg(paste0(paste0(x_divide), paste0(" = ", x_divide_first)), "Take first digit")
  
  x_plus_one <- x_divide_first + 1
  npi_msg(paste0(paste0(x_divide_first, " + ", 1), paste0(" = ", x_plus_one)), "Add one")
  
  x_paste_zero <- paste0(x_plus_one, "0")
  npi_msg(paste0(paste0(x_plus_one, " * ", 10), paste0(" = ", x_paste_zero)), "Multiply by 10")
  
  # Find the next higher number ending in zero
  x_next <- ceiling(x_24 / 10) * 10
  npi_msg(paste0(paste0("⌈", x_24,"⌉"), paste0(" = " , x_next)), "Next multiple of 10")
  
  # Find the check digit by subtracting x from y
  x_check <- x_next - x_24
  npi_msg(paste0(paste0(c(x_next, x_24), collapse = " - "), paste0(" = ", x_check)), "Find the check digit")
  
  # Append the check digit to the end of the 9-digit identifier
  id_10 <- id_9
  id_10[10] <- x_check
  
  npi_msg(paste0(id_10, collapse = ""), "Append check digit")
  
  # Collapse the vector into a single string
  npi_valid <- paste0(id_10, collapse = "")
  
  # Is the syntactically valid NPI identical to the test NPI?
  if (identical(npi_valid, npi_test)) {
    npi_msg(paste0(c(npi_test, npi_valid), collapse = " == "), "NPI is syntactically valid")
  }
  
  if (!identical(npi_valid, npi_test)) {
    npi_msg(paste0(c(npi_test, npi_valid), collapse = " != "), "NPI is not syntactically valid")
  }
  invisible(npi_valid)
}
```


### Testing Validation

```{r}
#| error: true
construct_npi_2(123456789)
construct_npi_2("123456789")
construct_npi_2("O123456789")
construct_npi_2("0000000000")
```

### Does it Work?

```{r}
construct_npi_2("1234567891")
construct_npi_2("1043477615")
construct_npi_2("1000000000")
```







