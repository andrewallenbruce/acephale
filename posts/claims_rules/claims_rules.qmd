---
title: "Building Claims Rules"
format: 
  html:
    reference-location: block
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false
knitr::opts_chunk$set(
  dev        = "ragg_png",
  dpi        = 300,
  out.width  = "100%",
  fig.width  = 8,
  fig.asp    = 0.618,
  fig.retina = 2,
  fig.align  = "center",
  fig.show   = "hold")

options(scipen = 999)
library(here)
library(tidyverse)
library(janitor)
library(gt)
library(fuimus)

head_tail <- function(x, n = 5, by = NULL) {
  dplyr::bind_rows(
    dplyr::slice_head(x, n = n, by = dplyr::all_of(by)),
    dplyr::slice_tail(x, n = n, by = dplyr::all_of(by)))
}

count_unique <- \(df, 
                  ..., 
                  .rename_first = "value", 
                  .set_names, 
                  .names_to = "variable") {
  
  df <- fuimus::df_2_chr(df)
  df <- dplyr::select(df, ...) |> 
    names() |> 
    purrr::map(~ dplyr::count(df, .data[[.x]], sort = TRUE)) |> 
    purrr::set_names(nm = .set_names)
  
  first_column_rename <- \(x, first = .rename_first) {
    for (i in 1:length(x)) {
      colnames(x[[i]])[1] <- first
      }
    x
  }
  
  first_column_rename(df) |> 
    purrr::list_rbind(names_to = .names_to)
}

rules <- read_csv(
  here("posts/claims_rules/data/rules_raw.csv"),
  col_types = cols(
  row       = col_integer(),
  id_rule   = col_integer(),
  id_name   = col_character(),
  id_order  = col_integer(),
  category  = col_factor(),
  alert     = col_character(),
  var       = col_character(),
  action    = col_character(),
  value     = col_character(),
  rule      = col_character(),
  x9        = col_character(),
  x10       = col_character())) |> 
  select(
    row,
    rid   = id_rule,
    rord  = id_order,
    rnm   = id_name,
    rvar  = var,
    ract  = action,
    rval  = value,
    rcat  = category,
    rdesc = rule,
    rmsg  = alert
  ) |>
  mutate(
    rcat  = remove_quotes(as.character(rcat)),
    rcat  = str_remove_all(rcat, "\\r|\\n"),
    rmsg  = remove_quotes(rmsg),
    rmsg  = str_remove_all(rmsg, "\\r|\\n"),
    rdesc = remove_quotes(rdesc),
    rdesc = str_remove_all(rdesc, "\\r|\\n")) |> 
  fill(rdesc)
```


## Descriptors Overview

-   [ ] `rcat`: Move urls to own column
-   [ ] `rnm`: split letters/numbers, categorize further
-   [ ] `rdesc`: human readable full rule
-   [ ] `rmsg`: actually the description or explanation

```{r}
#| label: rules_desc
#| echo: true
#| message: false
#| warning: false
rules_desc <- rules |> 
  select(rid, rnm, rcat, rdesc, rmsg) |> 
  distinct()

rules_desc |> 
  count_unique(rnm, rcat, rdesc, rmsg, 
               .set_names = c("name", "category", "description", "message"))
```


## Components Overview 

```{r}
#| label: rules_parts
#| echo: true
#| message: false
#| warning: false
rules_parts <- rules |> 
  select(rid, rord, rvar, ract, rval)

rules_parts |> 
  count_unique(rid, rord, rvar, ract, rval,
               .set_names = c("id", "step", "variable", "action", "value"))
```


## Recode Variables to Reduce Duplication

```{r}
#| label: recode_var
#| echo: true
#| message: false
#| warning: false
rules_parts <- rules_parts |>
  mutate(rvar = case_match(
    rvar,
      c("CPT CODE", 
        "CPT Code", 
        "CPT code", 
        "CPT", 
        "Code Check Expired CPT Alert (Presence)", 
        "CPT is one of") ~ "hcpcs",
      c("Mod1", 
        "CPT Mod1", 
        "CPT Mod 1", 
        "CPTMod1", 
        "Code Check CPT Mod Alert (Presence)", 
        "CPT MOD1", 
        "CPT Mod1 (Presence)") ~ "mod_1",
      c("Mod2", 
        "CPT MOD2", 
        "CPT Mod 2", 
        "CPT Mod2 (Presence)", 
        "CPTMod2", 
        "CPT Mod2") ~ "mod_2",
      "CPT Mod3" ~ "mod_3",
      "CPT Mod4" ~ "mod_4",
      "CPT Units" ~ "unit",
      c("Dx code", 
        "DX Code", 
        "Dx Code", 
        "Code Check Expired DX Alert (Presence)") ~ "icd",
      c("Encounter Date of Service", 
        "Date of Service") ~ "dos",
      c("Location", 
        "Place of Service") ~ "pos",
      c("CPT UB04", 
        "UB04 Bill Type") ~ "ub04",
      "CPT NDC (Presence)" ~ "ndc",
      "CPT Rev Code" ~ "rev_code",
      "Code Check CCI Alert (Presence)" ~ "cci",
      "Code Check LCD Alert (Presence)" ~ "lcd",
      "Code Check NCD Alert (Presence)" ~ "ncd",
      c("Patient Age", 
        "Code Check Age Alert (Presence)") ~ "dob",
      c("Patient Sex", 
        "Code Check Gender Alert (Presence)") ~ "sex",
      "NA" ~ NA_character_,
      "Rendering Provider" ~ "rendering",
      "Referring Provider (Presence)" ~ "referring",
      c("Primary Insurance Class", 
        "Primary Insurance class", 
        "Primary insurance class") ~ "primary_class",
      "Primary Insurance" ~ "primary_name",
      "Secondary Insurance Class" ~ "secondary_class",
      "Secondary Insurance" ~ "secondary_name",
      c("Primary Insurance Authorization (Presence)", 
        "Primary Insurance Authorization (Presence) is not [Present]") ~ "primary_auth",
      .default = rvar) |> 
      as_factor()
    )

rules_parts |> 
  count_unique(rid, rord, rvar, ract, rval,
               .set_names = c("id", "step", "variable", "action", "value"))
```


```{r}
#| label: cat_vars
#| echo: true
#| message: false
#| warning: false
rules_parts |> 
  filter(!is.na(ract)) |>
  count(rvar, ract) |> 
  arrange(rvar, desc(n)) |> 
  reframe(
    var_name = rvar,
    var_type = case_match(rvar,
      c("sex", "rendering", "referring", 
        "primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name", "ncd", "lcd", 
        "cci", "ndc", "ub04", "pos", 
        "icd", "hcpcs", "mod_1", "mod_2", 
        "mod_3", "mod_4") ~ "<chr>",
      c("rev_code", "unit") ~ "<int>",
      c("dos", "dob") ~ "<date>"
    ) |> as_factor(),
    var_class = case_match(as.character(rvar),
      c("sex", "dos", "dob") ~ "patient",
      c("rendering", "referring") ~ "provider",
      c("hcpcs", "mod_1", "mod_2", "mod_3", "mod_4", 
        "rev_code", "unit", "ndc", "pos") ~ "procedure",
      c("icd") ~ "diagnosis",
      c("ub04", "1500") ~ "claim",
      c("ncd", "lcd", "cci") ~ "ncci",
      c("primary_auth", "primary_class", 
        "primary_name", "secondary_class", 
        "secondary_name") ~ "payer"
    ) |> as_factor(),
    var_action = ract
  ) |> 
  select(
    var_type, 
    var_class, 
    var_name, 
    var_action) |> 
  arrange(var_type, var_class, var_name) |>
  print(n = 100)
```

## Date of Service

```{r}
rules_parts |> 
  filter(rvar == "dos") |> 
  mutate(type = "<date>",
         rval = anytime::anydate(rval),
         op = if_else(str_detect(ract, "after"), ">", "<")) |> 
  select(rid, rord, type, rvar, op, rval)
```

## Patient Age

```{r}
rules_parts |> 
  filter(rvar == "dob") |> 
  mutate(
    var = "age",
    type = "<int>", 
    .before = var) |> 
  mutate(age = strex::str_extract_numbers(rval),
         time = strex::str_extract_non_numerics(rval)) |> 
  unnest(c(age, time)) |> 
  mutate(
    age = as.integer(age),
    time = str_remove_all(time, "\\s|,"),
    rval = NULL,
    op = case_match(ract,
                    c("is younger than", "younger than") ~ "<",
                    "is older than" ~ ">",
                    "is" ~ "==",
                    .default = NA_character_
                    ),
    days = case_when(
      time == "years" ~ as.duration(years(age)) / ddays(1),
      time == "months" ~ as.duration(months(age)) / ddays(1),
      time == "days" ~ as.duration(days(age)) / ddays(1),
      .default = NA_real_
    ),
    dos = lubridate::today(),
  ) |> 
  select(rid, rord, type, rvar, op, age, time, days) |> 
  print(n = 1000)
```

## Unit (HCPCS)

```{r}
rules_parts |> 
  filter(rvar == "unit") |> 
  mutate(type = "<int>", 
         rval = as.integer(rval),
         .before = rvar, 
         op = if_else(
           str_detect(ract, "is not"), 
           "!=", "=="))
```

## NDC

How can this be represented in relational algebra? Detect presence with regex?

If not present, then is `NA` its' representation? If so, `is.na(x)` would equal `is not present` and `!is.na(x)` would equal `is present`


```{r}
rules_parts |> 
  filter(rvar == "ndc") |> 
  mutate(type = "<lgl>", 
         .before = rvar, 
         op = if_else(
           str_detect(ract, "is not"), 
           "is.na(x)", 
           "!is.na(x)")
         ) |> 
  print(n = 24)
```

## ICD

   * has all
   * is
   * is not
   * is one of

some values contain wildcards *

```{r}
rules_parts |> 
  filter(rvar == "icd") |>
  mutate(wc = case_when(str_detect(rval, "\\*") ~ 1L, .default = 0L),
         wc_nchar = if_else(wc ==1, str_count(rval, "[[:alnum:]]"), 0L),
         type = "<chr>",
         .after = rord) |> 
  mutate(op = case_when(
           ract == "is" & wc == 1 ~ "%in%",
           ract == "is" & wc == 0 ~ "==",
           .default = NA_character_),
         .after = rvar) |> 
  filter(!is.na(op)) |> 
  print(n = 124)
```


```{r}
#| label: vars
#| echo: true
#| message: false
#| warning: false
# categorize_vars |>
#   separate_longer_delim(cols = value, delim = ",") |> 
#   mutate(value = str_squish(value),
#          neg = case_when(str_detect(action, "not") ~ 1L, .default = 0L),
#          wc = case_when(str_detect(value, "\\*") ~ 1L, .default = 0L),
#          .after = value)
# 
# head_tail(rules_new, n = 10, by = c("var", "action")) |> 
#   gt() |> 
#   cols_align(align = "left") |>
#   opt_table_font(font = google_font(name = "Roboto Condensed")) |> 
#   opt_all_caps() |> 
#   tab_style(
#       style = cell_text(
#         align = 'left',
#         weight = "bold",
#         font = google_font(name = "Roboto Mono")),
#       locations = cells_body(columns = c(var, action, value))) |> 
#   tab_options(table.width = pct(100),
#               quarto.disable_processing = TRUE)

# rules_new |>
#   filter(!is.na(var)) |> 
#   group_by(var) |>
#   count(action) |>
#   ungroup() |>
#   arrange(var, desc(n), action) |> 
#   gt(groupname_col = "var", row_group_as_column = TRUE) |> 
#   cols_align(align = "left") |>
#   opt_table_font(
#     font = google_font(name = "Roboto Condensed"),
#     weight = "bold"
#     ) |> 
#   opt_all_caps() |> 
#   tab_style(
#       style = cell_text(
#         align = 'left',
#         weight = "normal",
#         font = google_font(name = "Roboto Mono")),
#       locations = cells_body(columns = c(var, action))) |> 
#   tab_options(table.width = pct(100),
#               quarto.disable_processing = TRUE)
```


## Regexes

```{r}
#| label: regex
#| echo: true
#| message: false
#| warning: false
# rules_new |> 
#   filter(wc == 1,
#          var == "hcpcs") |>
#   mutate(value = str_remove_all(value, "\\*"),
#          chars = 5 - str_length(value),
#          .after = value) |> 
#   mutate(
#     regex = case_when(
#       chars == 0 ~ glue_chr("^<<value>>$", .open = "<<", .close = ">>"),
#       chars == 1 ~ glue_chr("^<<value>>[0-9]$", .open = "<<", .close = ">>"),
#       chars > 1 ~ glue_chr("^<<value>>[0-9]{<<chars>>}$", .open = "<<", .close = ">>")),
#     regex = case_when(neg == 1L ~ glue_chr('!{regex}'), .default = regex),
#     .after = regex
#   ) |> 
#   head_tail(n = 10, by = c("var", "action")) |> 
#   gt() |> 
#   cols_align(align = "left") |>
#   opt_table_font(font = google_font(name = "Roboto Condensed")) |> 
#   opt_all_caps() |> 
#   tab_style(
#       style = cell_text(
#         align = 'left',
#         weight = "bold",
#         font = google_font(name = "Roboto Mono")),
#       locations = cells_body(columns = c(regex))) |> 
#   tab_options(table.width = pct(100),
#               quarto.disable_processing = TRUE)
```


```{r}
#| label: misc
#| eval: false
#| echo: true
#| message: false
#| warning: false
northstar::search_descriptions(hcpcs_desc_type = "Long") |> 
  # dplyr::mutate(not_hcpcs = !grepl("^99[0-9]{3}$", hcpcs_code)) |> 
  filter(!grepl("^99[0-9]{3,3}$", hcpcs_code)) |>
  # dplyr::mutate(has_hcpcs = grepl("^J[0-9]{4}$", hcpcs_code)) |> 
  filter(str_detect(hcpcs_code, regex("^J[0-9]{4}$"))) |> 
  filter(str_detect(hcpcs_code, regex("^(?!5405)(?<![0-9]{1})$"))) |> 
  print(n = 200)

# Match strings that don't start with "99" and don't end with 3 digits
pattern <- "^(?!99).*(?<![0-9]{3})$"

# Negation pattern
"^(?!9938[0-9]{1}$)"

# Begins with 0, ends with digit
"^0.*\\d$"

# Begins with 0, ends with letter
"^0.*[A-Z]$"

# Match strings that don't start with "a" and don't end with "z"
pattern <- "^(?!a).*[^z]$"
grep(pattern, c("apple", "banana", "cherry"), value = TRUE)
# Output: "banana" "cherry"

stringr::str_detect("99202", stringr::regex("^[992]{3}.*"))

grep("^[992]{3}.*", "99202", value = TRUE, invert = TRUE)


# pattern = dplyr::case_when(
#   chars == 0 & negation == FALSE ~ glue::glue("^<value>$", .open = "<", .close = ">"),
#   chars > 0  & negation == FALSE ~ glue::glue("^<value>[0-9]{<chars>}$", .open = "<", .close = ">"),
#   chars == 0 & negation == TRUE ~ glue::glue("^(?!<value>)$", .open = "<", .close = ">"),
#   chars > 0  & negation == TRUE ~ glue::glue("^(?!<<value>>)(?<![0-9]{<<chars>>})$", .open = "<<", .close = ">>")
#   ),
```
