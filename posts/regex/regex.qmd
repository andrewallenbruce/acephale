---
title: "Learning to Love Regexes By Learning Them"
subtitle: "I Promised Myself I Wouldn't Do This Again"
description: "Building a regex generator for self-contained, well-defined string detection problems is a very effective way to learn regular expressions."
format:
  html:
    reference-location: margin
    other-links:
      - text: Regex Cheatsheet
        icon: bookmark-plus
        href: https://github.com/raredd/regex
      - text: RexEgg
        icon: bookmark-plus
        href: https://www.rexegg.com/
      - text: Regex in R
        icon: bookmark-plus
        href: https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| message: false
#| warning: false
#| echo: false
#| cache: false
knitr::opts_chunk$set(
  collapse  = FALSE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "",
  dpi       = 300, 
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)
options(scipen = 999, digits = 2)

library(fuimus)
library(codex)

library(dplyr)
library(purrr)
library(stringr)
library(rlang)
library(cli)
library(dtplyr)
library(vctrs)

library(stringfish)
library(data.table)
library(collapse)
library(kit)
library(emphatic)
library(compiler)
library(cheapr)
library(fastplyr)

# library(re2)
# library(re2r)
# library(tidyfast)
# library(tidytable)
source(here::here("posts/regex/scripts", "data.R"))
```

# HCPCS

```{r}
#| label: hcpcs_all
#| echo: false
#| results: asis
rx <- list(
  All              = "^[A-CEGHJ-MP-V0-9][0-9]{3}[AFMTU0-9]$",
  "-Level I"       = "^[0-9]{4}[AFMTU0-9]$",
  "--Category I"   = "^[0-9]{4}[AMU0-9]$",
  "--Category II"  = "^[0-9]{4}F$",
  "--Category III" = "^[0-9]{4}T$",
  "-Level II"      = "^[A-CEGHJ-MP-V][0-9]{4}$"
)

greys <- c("black", "grey20", "grey50", "grey80", "grey90", "grey20")

len <- \(rx) cheapr::vector_length(vctrs::vec_slice(hcpcs, sf_detect(hcpcs, rx)))

data.frame(
  row.names = names(rx),
  Count = map_int(delist(rx), len), 
  Regex = delist(rx)) |> 
  hl(greys, cols = 1) |>
  knit_print.emphatic()
```

# TODO

   * If a **wildcard** begins with a **letter**, the *postfix* should be `[0-9]{n}`.
   * In `remove_redundant()`, try pmap for `rr()` step.


## Checklist

-   [X] `split_lengths()`
-   [X] `remove_redundant()`
-   [X] `split_first()`
-   [ ] `process_groups()`
   - `group_3()`
   - `group_4()`
   - `group_5()`
-   [ ] `reduce_groups()`
   - `reduce_runs()`
   - `vec_to_regex()`
   - `red1()`
   - `red2()`
   - `red3()`

```{r}
#| label: helpers
#| echo: false
cutoff <- \(x) stringr::str_trunc(string = x, width = 40, side = "right")
wrap   <- \(x) stringr::str_wrap(string = x, width = 60, exdent = 5, whitespace_only = FALSE)

view <- \(x) {
  idx  <- seq_along(x)
  len  <- vlen(x)
  tree <- unname(purrr::map_vec(x, paste0, collapse = " ")) |> purrr::map_vec(cutoff)
  
    glue::glue("{format(idx)}: ", 
               "{format(len)}|", 
               "--[{if (empty(tree)) NULL else format(tree, justify = 'none')}]")
}

view_remove <- \(x) {
  
  len  <- length(x)
  tree <- unname(paste0(x, collapse = " ")) |> purrr::map_vec(cutoff)
  
  glue::glue("Removed ", 
             "{format(len, justify = 'left')}|", 
             "--[{if (empty(tree)) NULL else format(tree, justify = 'none')}]")
}
```

# Preprocessing

::: {.panel-tabset}

## `split_lengths()`

```{r}
#| label: split_lengths
#| message: true
#| echo: true
split_lengths <- function(x, verbose = FALSE) {
  
  stopifnot(is.character(x))
  
  x <- sf_remove(x, "\\*|\\s") |> 
    unique_narm() |> 
    stringr::str_sort()
  
  l <- vlen(x)
  
  out <- list(
    x1 = x[l == 1],
    x2 = x[l == 2],
    x3 = x[l == 3],
    x4 = x[l == 4],
    x5 = x[l == 5])
  
  if (verbose) {
    
    cli::cat_boxx(
      label = view(out), 
      header = glue::glue("{cli::symbol$stop} Split By Lengths"),
      align = "left", 
      padding = c(0, 1, 0, 1))
    
    return(invisible(out))
    
  } else {
    return(out)
  }
}

random_hcpcs() |>
  split_lengths()
```

## `remove_redundant()`

If a vector contains both `"A"` and `"A0"`, remove `"A0"`, i.e., remove longer codes that share a common sub-string with shorter codes.

```{r}
#| label: remove_redundant
remove_redundant <- function(x, verbose = FALSE) {

  .c(x1, x2, x3, x4, x5) %=% x
  
  out <- list(
    x1 = x1,
    x2 = rr(x2, x1),
    x3 = rr(x3, x1) |> rr(x2),
    x4 = rr(x4, x1) |> rr(x2) |> rr(x3),
    x5 = rr(x5, x1) |> rr(x2) |> rr(x3) |> rr(x4)
  )
  
  if (verbose) {
    
    cli::cat_boxx(
      label = view(out), 
      header = glue::glue("{strrep(cli::symbol$stop, 2)} Remove Redundancies"),
      align = "left", 
      padding = c(0, 1, 0, 1))

    return(invisible(out))
    
  } else {
    return(out)
  }
}

random_hcpcs() |> 
  split_lengths() |> 
  remove_redundant()
```

## `split_first()`

```{r}
#| label: split_first
#| message: true
#| echo: true
split_at <- \(x, y = x, i, z) collapse::rsplit(x, sf_sub(y, i, z), use.names = FALSE)

split_1 <- \(x) split_at(x, y = x, i = 1, z = 1)

split_end <- \(x) {
  
  if (any(sf_detect(x, "[A-Z]$"))) {
    
    end <- sf_extract(x, "[A-Z]$")
    beg <- glue::glue("{take_at(end, 5)}{sf_remove(end, '[A-Z]$')}")

  c(split_at(x = x[!sf_detect(x, "[A-Z]$")], i = 1, z = 1),
    split_at(x = end, y = beg, i = 1, z = 2))
  
  } else {
    
  split_at(x, i = 1, z = 1)
    
  }
}

split_first <- function(x, verbose = FALSE) {
  
  .c(x1, x2, x3, x4, x5) %=% x
  
  out <- list(
    x1 = list(x1),
    x2 = split_1(x2),
    x3 = split_1(x3),
    x4 = split_1(x4),
    x5 = split_end(x5))
  
  if (verbose) {
    
    cli::cat_boxx(
      label = view(out), 
      header = glue::glue("{strrep(cli::symbol$stop, 3)} Split At First"),
      align = "left", 
      padding = c(0, 1, 0, 1))
    
    return(invisible(out))
    
  } else {
    return(out)
  }
}

random_hcpcs(50) |> 
  split_lengths() |>
  remove_redundant() |>
  split_first()
```

### Letters

```{r}
#| label: starts_ends_with_letter
#| echo: false
#| message: true
end_chr <- stringfish::convert_to_sf(sf_extract(hcpcs, "[A-Z]$"))

message("HCPCS Ending with Letter")
print_ls(as.list(table(sf_extract(sf_sub(end_chr, 5, 5), "[A-Z]"))))
message("Total: ", length(end_chr))

start_chr <- stringfish::convert_to_sf(sf_extract(hcpcs, "^[A-Z]"))

message("HCPCS Beginning with Letter", sep = "\n")
print_ls(as.list(table(sf_extract(sf_sub(start_chr, 1, 1), "[A-Z]"))))
message("Total:", length(start_chr))
```

::: 

# Grouping

Group each set of vectors into regex patterns. Deal with groups containing letters separately.

::: {.panel-tabset}

## Group 3

```{r}
#| label: group_3
#| eval: true
group_3 <- function(x) {

  x <- collapse::get_elem(x, "x3")
  
  if (empty(x)) return(x)
  
  purrr::map(x, function(x) {
    
    idx <- data.table::data.table(
      code = x,
      grp = sf_sub(x, 1, 2),
      a1 = take_at(x),
      a2 = take_at(x, 2),
      a3 = take_at(x, 3),
      i1 = collapse::groupid(take_at(x)),
      i2 = collapse::groupid(take_at(x, 2))) |>
      # collapse::fgroup_by(a1) |>
      # collapse::fmutate(i2 = collapse::groupid(a2)) |>
      collapse::fgroup_by(a1, a2) |>
      collapse::fmutate(i3 = collapse::groupid(a3)) |> 
      collapse::fungroup()
      
      lone <- collapse::fcount(idx, i1, add = TRUE) |>
        collapse::fsubset((i2 + i3 + N) == 3)
      
      last <- collapse::fsubset(idx, code %!in% lone[["code"]])
      
      last <- collapse::join(
        collapse::fcount(last, a1, a2),
        collapse::fcount(last, a1, name = "G"), on = "a1", verbose = 0) |>
        collapse::fsubset(N == G) |>
        collapse::join(last, on = c("a1", "a2"), how = "right", verbose = 0) |>
        collapse::fsubset(!cheapr::is_na(N))
      
      rest <- collapse::fsubset(idx, code %!in% c(lone[["code"]], last[["code"]]))
      
      c(if (empty(lone)) NULL else list(lone[["code"]]),
        if (empty(last)) NULL else codex::chop(last[["code"]], last[["a1"]]),
        if (empty(rest)) NULL else codex::chop(rest[["code"]], rest[["grp"]]))
    })
}

c("C75", "C97", "G02", "G04") |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_3()

long_test2[nchar(long_test2) == 3] |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_3()

random_hcpcs(50) |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_3()
```

## Group 4

```{r}
#| label: group_4
#| eval: true
group_4 <- function(x) {

  x <- collapse::get_elem(x, "x4")
  
  if (empty(x)) return(x)
  
  purrr::map(x, function(x) {
    
    idx <- data.table::data.table(
      code = x,
      grp1 = sf_sub(x, 1, 2),
      grp2 = sf_sub(x, 1, 3),
      a1 = take_at(x),
      a2 = take_at(x, 2),
      a3 = take_at(x, 3),
      a4 = take_at(x, 4),
      i1 = collapse::groupid(take_at(x))) |>
      collapse::fgroup_by(a1) |>
      collapse::fmutate(i2 = collapse::groupid(a2)) |>
      collapse::fgroup_by(a1, a2) |>
      collapse::fmutate(i3 = collapse::groupid(a3)) |> 
      collapse::fgroup_by(a1, a2, a3) |>
      collapse::fmutate(i4 = collapse::groupid(a4)) |> 
      collapse::fungroup()
    
    lone <- collapse::fcount(idx, i1, add = TRUE) |>
        collapse::fsubset((i2 + i3 + i4 + N) == 4)
    
    last <- collapse::fsubset(idx, code %!in% lone[["code"]])
    
    last <- collapse::join(
        collapse::fcount(last, grp1, a3),
        collapse::fcount(last, grp1, name = "G"), on = "grp1", verbose = 0) |>
        collapse::fsubset(N == G) |>
        collapse::join(last, on = c("grp1", "a3"), how = "right", verbose = 0) |>
        collapse::fsubset(!cheapr::is_na(N))
    
      rest <- collapse::fsubset(idx, code %!in% c(lone[["code"]], last[["code"]]))
      
      c(if (empty(lone)) NULL else list(lone[["code"]]),
        if (empty(last)) NULL else codex::chop(last[["code"]], last[["grp1"]]),
        if (empty(rest)) NULL else codex::chop(rest[["code"]], rest[["grp2"]]))
    })
}

c("C751", "C970", "G020", "G040") |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_4()

long_test2[nchar(long_test2) == 4] |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_4()

random_hcpcs(50) |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_4()
```

## Group 5

```{r}
#| label: group_5
#| eval: true
group_5 <- function(x) {

  x <- collapse::get_elem(x, "x5")
  
  if (empty(x)) return(x)
  
  purrr::map(x, function(x) {
    
    indices <- data.table::data.table(
      code = x,
      a1 = take_at(x),
      a2 = take_at(x, 2),
      a3 = take_at(x, 3),
      a4 = take_at(x, 4),
      a5 = take_at(x, 5)) |>
      dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |>
      dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |>
      dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |>
      dplyr::mutate(i4 = dplyr::consecutive_id(a4), .by = c(a1, a2, a3)) |> 
      dplyr::mutate(i5 = dplyr::consecutive_id(a5), .by = c(a1, a2, a3, a4))
      
      orphans <- indices |>
        dplyr::add_count(i1, name = "n1", sort = TRUE) |>
        dplyr::filter((i2 + i3 + i4 + i5 + n1) == 5) |>
        dplyr::pull(code)
      
      last <- indices |>
        dplyr::filter(code %!in% orphans) |>
        dplyr::select(code, a1:a5) |>
        fuimus::combine(group_id, columns = c("a1", "a2", "a3"), sep = "")
      
      last <- dplyr::left_join(
        last |> dplyr::count(group_id, a4),
        last |> dplyr::count(group_id, name = "g"),
        by = dplyr::join_by(group_id)) |>
        dplyr::filter(n == g) |>
        dplyr::right_join(last, by = dplyr::join_by(group_id, a4)) |>
        dplyr::filter(!is.na(n))
      
      rest <- indices |>
        dplyr::filter(code %!in% c(orphans, dplyr::pull(last, code))) |>
        fuimus::combine(group_id, columns = c("a1", "a2", "a3", "a4"), sep = "")
      
      vctrs::vec_c(
        if (empty(orphans)) NULL else list(orphans),
        if (empty(last)) NULL else chop(last$code, last$group_id),
        if (empty(rest)) NULL else chop(rest$code, rest$group_id))
    })
}

c("C7510", "C9701", "G0200", "G0400") |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_5()

long_test2[nchar(long_test2) == 5] |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_5()

random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  group_5()
```

## process_groups

```{r}
#| label: process_groups
process_groups <- function(x) {
  
  list(
    g1 = x$x1,
    g2 = x$x2,
    g3 = group_3(x),
    g4 = group_4(x),
    g5 = group_5(x)
    )
}

hcpcs_tests |>
  split_lengths() |> 
  # remove_redundant() |> 
  split_first() |>
  process_groups()

long_test2 |> 
  split_lengths() |> 
  # remove_redundant() |> 
  split_first() |> 
  process_groups()

random_hcpcs(50) |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  process_groups()
```

### Problems

```{r}
#| label: edge_cases
#---------- 1
## Problem
list("L80", c("L56", "L59"))

## Solution
"^L(5[69]|80)$"

## Test
sf_extract(hcpcs, "^L(5[69]|80)[0-9]{2}$")

#---------- 2
## Problem
list(c("021", "022", "026", "027"), c("032", "033"), c("042", "044"), "050")

## Solution
"^0(2[1267]|3[23]|4[24]|50)[A-Z0-9]{2}$"

## Test
sf_extract(hcpcs, "^0(2[1267]|3[23]|4[24]|50)[A-Z0-9]{2}$")

#---------- 3
# How do you tell the difference?

## Problem
list(c("C75", "C97"), c("G02", "G04"))

## Solution
"^C(75|97)[A-Z0-9]{2}$"

"^G0[24][A-Z0-9]{2}$"

## Test
sf_extract(hcpcs, "^C(75|97)[0-9]{2}$|^G0[24][0-9]{2}$")
```

::: 

# Reduction

::: {.panel-tabset}

## `reduce_runs()`

```{r}
#| label: reduce_runs
#| echo: true
#| eval: true
reduce_runs <- function(x) {
  
  if (nchar(x) == 1) return(x)

  poss <- c(0:9, "&", LETTERS)
  
  test <- setNames(rep(0, 37), poss)
  
  vctr <- test[c(splitter(x), "&")]
  
  vctr <- vctr[!is.na(vctr)]
  
  test[names(vctr)] <- 1
  
  test[names(test) == "&"] <- 0

  groups <- data.table::data.table(
    value = names(test),
    keys = test,
    group = dplyr::consecutive_id(test)) |>
    dplyr::mutate(size = dplyr::n(), .by = group) |> 
    dplyr::filter(keys == 1, size >= 3) |>
    dplyr::select(value, group)

  if (empty(groups)) return(x)
  
  xgroups <- chop(groups$value, groups$group) |>
    purrr::map(smush) |>
    purrr::list_c()
  
  if (all(xgroups == smush(poss))) return("[A-Z0-9]")
  
  replacements <- dplyr::left_join(
    dplyr::slice_min(groups, by = group, order_by = value) |> dplyr::rename(start = value),
    dplyr::slice_max(groups, by = group, order_by = value) |> dplyr::rename(end = value),
    by = dplyr::join_by(group)) |>
    glue::glue_data("{start}-{end}") |>
    as.vector()

  res <- stringi::stri_replace_all_regex(x, xgroups, replacements, vectorize_all = FALSE)

  bracket(res)
}
```

## `red1()`

```{r}
#| label: red1
red1 <- function(x) {
  
  if (empty(x[["g1"]])) return(character(0))
  
  x <- collapse::get_elem(x, "g1")[[1]]
  
  re <- sort_order(x) |> reduce_runs()
  
  if (re == "[A-Z0-9]") return(glue::glue("^{re}{{5}}$"))
  
  post <- ifelse(sf_detect(re, "\\[?[0-9]{1}"), "[A-Z0-9]", "[0-9]")
  
  glue::glue("^{re}{post}{{4}}$")
}

hcpcs_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  split_first() |>
  process_groups() |> 
  red1()


c(LETTERS[1:5], 0:9) |> 
  split_lengths() |> 
  remove_redundant() |> 
  split_first() |>
  process_groups() |> 
  red1()

long_test2 |>
  split_lengths() |> 
  remove_redundant() |> 
  split_first() |>
  process_groups() |> 
  red1()

list(g1 = list(c(0:9, LETTERS))) |> 
  red1()

list(g1 = list(c(LETTERS[1:5], 0:9))) |> 
  red1()
```

## `red2()`

```{r}
#| label: red2
red2 <- function(x) {
  
  if (empty(x[["g2"]])) return(character(0))
  
  x <- collapse::get_elem(x, "g2")
  l <- vlen(x)
  
  c(x[l == 1], 
    purrr::map(x[l > 1], \(x) {
    
    parts <- stringr::str_split_fixed(x, "", max_vlen(x)) |> 
    as.data.frame() |>
    purrr::map(unique_narm) |>
    purrr::map(sort_order) |>
    purrr::map(reduce_runs) |>
    delist()
  
  multi <- stringfish::sf_nchar(parts, nthreads = 4L) > 1
  nobrk <- !sf_detect(parts[multi], "\\[|\\]")
  
  parts[multi] <- ifelse(any(nobrk), purrr::map_chr(parts[multi], bracket), parts[multi])
  
  smush(parts)
    
  })
  )
}

all_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  split_first() |>
  process_groups() |> 
  red2()

hcpcs_tests |>
  split_lengths() |>
  remove_redundant() |>
  split_first() |>
  process_groups() |>
  red2()

paste0("A", c(0:5, LETTERS)) |> 
  split_lengths() |>
  remove_redundant() |>
  split_first() |>
  process_groups() |>
  red2()
```

## `red3()`

```{r}
#| label: grp_nest
#| eval: false
#| echo: false
grp_nest <- long_test2[nchar(long_test2) == 3] |> 
  split_lengths() |> 
  remove_redundant() |>
  split_first() |>
  process_groups()

# grp_nest$g3
# 
# depth <- purrr::map_int(grp_nest$g3, purrr::pluck_depth)
# 
# depth
# 
# grp_nest$g3[depth == 1]
# grp_nest$g3[depth > 1]
# 
# len <- vlen(grp_nest$g3)
# 
# len
# 
# grp_nest$g3[len == 1]
# grp_nest$g3[depth > 1]
# 
# pluck(grp_nest, 7)


x <- grp_nest
```

```{r}
#| label: red3
#| eval: false
red3 <- function(x) {
  
  if (empty(x[["g3"]])) return(character(0))
  
  x <- collapse::get_elem(x, "g3")
  d <- purrr::map_int(x, purrr::pluck_depth)
  
  top   <- x[d == 1]
  leave <- top[vlen(top) == 1]
  top   <- top[vlen(top) > 1]
  nest  <- x[d > 1]
  
  first <- purrr::map_chr(nest[[1]], function(x) take_at(purrr::pluck(x, 1, 1)[1])) |> collapse::funique()
  
  rest <- purrr::map(nest[[1]], function(x) sf_remove(x, glue::glue("^{first}")))
  
  vctrs::vec_c(
    leave, 
    purrr::map(top, function(x) {
      x <- top[[1]]
      x <- top[[2]]
      
      parts <- stringr::str_split_fixed(x, "", n = max_vlen(x)) |> 
        as.data.frame() |>
        purrr::map(unique_narm) |> 
        purrr::map(sort_order) |>
        purrr::map(reduce_runs) |> 
        delist()
      
      multi <- stringfish::sf_nchar(parts, nthreads = 4L) > 1
      
      if (any(multi)) parts[multi] <- parent(paste0(parts[multi], collapse = "|"))
      
      smush(unique_narm(parts))
    })
  )
}
```

::: 

# Reduce Groups

```{r}
#| label: reduce_groups
#| eval: false
#| message: false
#| error: true
vec_to_regex <- vrg <- \(x, n) {
  
  if (empty(x)) return(character(0))
  
  post <- ifelse(sf_detect(x, "^\\[?[A-Z]\\-?"), "[0-9]", "[A-Z0-9]")
  
  x <- data.table::fcase(
    n == 0, glue::glue("^{x}$"),                
    n == 1, glue::glue("^{x}{post}$"),
    n == 2, glue::glue("^{x}{post}{{2}}$"),
    n == 3, glue::glue("^{x}{post}{{3}}$")
    )
    
  glue::glue_collapse(x)
}

reduce_groups <- \(x) {
  
  list(
    g1 = p1(x),
    g2 = purrr::map_chr(x$g2, p2) |> purrr::map_chr(vrg, n = 3) |> glue::as_glue(),
    g3 = purrr::map_chr(x$g3, p2) |> purrr::map_chr(vrg, n = 2) |> glue::as_glue(),
    g4 = purrr::map_chr(x$g4, p2) |> purrr::map_chr(vrg, n = 1) |> glue::as_glue(),
    g5 = purrr::map_chr(x$g5, p2) |> purrr::map_chr(vrg, n = 0) |> glue::as_glue()
  )
}

all_tests[nchar(all_tests) > 2] |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

hcpcs_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

# long_test2[nchar(long_test2) == 4]

new_test |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

random_hcpcs() |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()
```

```{r}
#| label: final_output
#| eval: false
#| echo: false
#| message: false
#| error: true
medrex <- function(x, verbose = TRUE) {
  x |> 
    split_lengths(verbose = verbose) |> 
    remove_redundant(verbose = verbose) |> 
    process_groups(verbose = verbose) |> 
    reduce_groups() |> 
    unlist(use.names = FALSE) |> 
    glue::glue_collapse(sep = "|")
}

long_test2[nchar(long_test2) > 4]

# REMOVE {1} FROM EXPRS WITH 5 CHARS

medrex(long_test2[nchar(long_test2) > 4])

vctrs::vec_slice(
  hcpcs, 
  stringfish::sf_grepl(
    hcpcs, 
    medrex(
      long_test2[nchar(long_test2) > 4],
      verbose = FALSE
      )
    )
  )
```


{{< pagebreak >}}

::: {#nte-references .callout-tip collapse="true"}

## Links
### Reference

   - [Regex Cheatsheet](https://github.com/raredd/regex)
   - [Learn Regex](https://github.com/ziishaned/learn-regex)
   - [Evaluating strings as code](https://josiahparry.com/posts/2024-06-13-eval-strings)
   - [Building rules from code operands](https://github.com/Permian-Global-Research/rsi)
   - [Filter logic](https://github.com/atorus-research/ardis/blob/main/R/denom.R)
   - [Regular-Expression.info](https://www.regular-expressions.info/tutorial.html)
   - [RexEgg](https://www.rexegg.com/)
   - [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html)
   - [Debuggex](https://www.debuggex.com/)

### Packages

   - [**textshape**](https://github.com/trinker/textshape)
   - [**stringr.plus**](https://github.com/johncassil/stringr.plus)
   - [**regexmagic**](https://github.com/jonocarroll/regexmagic)
   - [**makeunique**](https://github.com/selkamand/makeunique)
   - [**similiars**](https://github.com/davidsjoberg/similiars)
   - [**strex**](https://github.com/rorynolan/strex/)
   - [**stringfish**](https://github.com/traversc/stringfish)
   - [**collapse**](https://sebkrantz.github.io/collapse/)
   - [**kit**](https://github.com/2005m/kit)
   - [**cheapr**](https://github.com/NicChr/cheapr)
   - [**fastplyr**](https://github.com/NicChr/fastplyr)
   - [**stringi**](https://stringi.gagolewski.com/)
   - [**qdapRegex**](https://github.com/trinker/qdapRegex)
   - [**charcuterie**](https://github.com/jonocarroll/charcuterie)

### Functions

   - [mark::globbing](https://github.com/jmbarbone/mark/blob/main/R/glob.R)
   - [RUtil::make_unique_comb](https://github.com/raivokolde/RUtil/blob/master/Source/R/make_unique_comb.r)
   - [mirmisc::longest_common_substring](https://github.com/mirvie/mirmisc/blob/main/R/utils.R)
   - [hutils::longest prefix/suffix](https://github.com/HughParsonage/hutils/blob/master/R/longest_affix.R)
   - [tidyext::combn_2_col](https://github.com/m-clark/tidyext/blob/master/R/combn_2_col.R)

::: 


## Session Information 

```{r}
#| echo: false
pander::pander(sessionInfo())
```
