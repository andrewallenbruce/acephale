---
title: "Learning to Love Regexes By Learning Them"
subtitle: "I Promised Myself I Wouldn't Do This Again"
description: "Building a regex generator for self-contained, well-defined string detection problems is a very effective way to learn regular expressions."
format:
  html:
    reference-location: margin
    other-links:
      - text: Regex Cheatsheet
        icon: bookmark-plus
        href: https://github.com/raredd/regex
      - text: RexEgg
        icon: bookmark-plus
        href: https://www.rexegg.com/
      - text: Regex in R
        icon: bookmark-plus
        href: https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| message: false
#| warning: false
#| echo: false
#| cache: false

knitr::opts_chunk$set(
  collapse  = FALSE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "",
  dpi       = 300, 
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)
options(scipen = 999)
library(tidyverse)
library(rlang)
library(vctrs)
library(cli)
library(stringfish)
library(zeallot)
library(data.table)
library(collapse)
library(cheapr)
library(fastplyr)
library(compiler)
library(re2)
library(re2r)

long_test <- stringfish::convert_to_sf(
  c(
    "0214T", "0215T", "0217T", "0218T", 
    "0219T", "0220T", "0221T", "0222T", 
    "0263T", "0265T", "0266T", "0269T", 
    "0274T", "0275T", "0329T", "0330T", 
    "0422T", "0444T", "0445T", "0506T", 
    "0507T", "15777", "20939", "22510", 
    "22511", "22512", "22513", "22514", 
    "22515", "22526", "22527", "27197", 
    "27198", "30801", "30802", "31231", 
    "32673", "34713", "34714", "34715", 
    "34716", "34717", "36221", "34812", 
    "34820", "34833", "34834", "35572", 
    "50300", "50540", "54420", "54430", 
    "55200", "55250", "55300", "58575", 
    "58600", "58605", "58700", "58720", 
    "58800", "58805", "58900", "58920", 
    "58925", "58940", "58943", "61000", 
    "61001", "61253", "63035", "63043", 
    "63044", "63045", "63046", "63047", 
    "63048", "64421", "64480", "64484", 
    "64491", "64492", "64494", "64495", 
    "64634", "64636", "76514", "92025", 
    "92081", "92082", "92083", "92132", 
    "92133", "92134", "92145", "92201", 
    "92202", "92227", "92228", "92229", 
    "92235", "92240", "92242", "95870", 
    "C7501", "C7502", "C7504", "C7505", 
    "C9771", "E0675", "G0279", "G0412",
    "G0413", "G0414", "G0415", "S2342"
))

hcpcs_tests <- sf_concat(
  c("J*", "G", "0", 4:6),
  c(as.character(30:32)),
  c(as.character(721:729)),
  c(as.character(5202:5208)),
  c(as.character(92015:92019)))

long_test2 <- sf_concat(
  sf_substr(long_test, 1, 1),
  sf_substr(long_test, 1, 2),
  sf_substr(long_test, 1, 3),
  sf_substr(long_test, 1, 4),
  sf_substr(long_test, 1, 5))

all_tests <- sf_concat(
  # sf_substr(long_test, 1, 1),
  sf_substr(long_test, 1, 2),
  sf_substr(long_test, 1, 3),
  sf_substr(long_test, 1, 4),
  sf_substr(long_test, 1, 5),
  hcpcs_tests)

hcpcs_codes <- convert_to_sf(funique(northstar::search_descriptions()$hcpcs_code))
```

# HCPCS

```{r}
#| label: hcpcs_all
#| echo: false
hcpcs_all_rx  <- "(^[A-CEGHJ-MP-V0-9][0-9]{3}[AFMTU0-9]$)"
hcpcs_lvI_rx  <- "(^[0-9]{4}[AFMTU0-9]$)"
cpt_cgI_rx    <- "(^[0-9]{4}[AMU0-9]$)"
cpt_cgII_rx   <- "(^[0-9]{4}F$)"
cpt_cgIII_rx  <- "(^[0-9]{4}T$)"
hcpcs_lvII_rx <- "(^[A-CEGHJ-MP-V][0-9]{4}$)"

hcpcs_all_ln  <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, hcpcs_all_rx)))
hcpcs_lvI_ln  <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, hcpcs_lvI_rx)))
cpt_cgI_ln    <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, cpt_cgI_rx)))
cpt_cgII_ln   <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, cpt_cgII_rx)))
cpt_cgIII_ln  <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, cpt_cgIII_rx)))
hcpcs_lvII_ln <- vector_length(vec_slice(hcpcs_codes, sf_grepl(hcpcs_codes, hcpcs_lvII_rx)))


dplyr::tibble(HCPCS = "Total", Count = hcpcs_all_ln, Regex = hcpcs_all_rx) |> 
  dplyr::add_row(HCPCS = "Level I (CPT)", Count = hcpcs_lvI_ln, Regex = hcpcs_lvI_rx) |> 
  dplyr::add_row(HCPCS = "CPT Category I", Count = cpt_cgI_ln, Regex = cpt_cgI_rx) |> 
  dplyr::add_row(HCPCS = "CPT Category II", Count = cpt_cgII_ln, Regex = cpt_cgII_rx) |> 
  dplyr::add_row(HCPCS = "CPT Category III", Count = cpt_cgIII_ln, Regex = cpt_cgIII_rx) |> 
  dplyr::add_row(HCPCS = "Level I (CPT)", Count = hcpcs_lvII_ln, Regex = hcpcs_lvII_rx) |> 
  gt::gt() |> 
  gt::fmt_number(columns = 2, decimals = 0)
```

# TODOs

   * If a **wildcard** begins with a **letter**, the *postfix* should be `[0-9]{n}`.
   * Eliminate `g1()` step in grouping.
   * `remove_redundant()`: Don't use `zeallot` infix, try pmap for `rr()` step.

## Preprocess

```{r}
#| label: internal_functions
`%notin%` <- data.table::`%notin%`
take      <- \(x, i = 1) stringfish::sf_substr(x, start = i, stop = i, nthreads = 4L)
empty     <- \(x) vctrs::vec_is_empty(x)
```

### 1. `split_lengths()`

```{r}
#| label: split_lengths
split_lengths <- function(x) {
  
  stopifnot(is.character(x))
  
  x <- stringfish::sf_gsub(x, "\\*|\\s", "", nthreads = 4L) |> 
      fuimus::uniq_rmna() |> 
    stringr::str_sort()
  
  l <- collapse::vlengths(x)
  
  list(
    x1 = x[l == 1],
    x2 = x[l == 2],
    x3 = x[l == 3],
    x4 = x[l == 4],
    x5 = x[l == 5]
  )
}
```

### 2. `remove_redundant()`

If a vector contains both `"A"` and `"A0"`, remove `"A0"`. Why? A user may input complete and incomplete HCPCS codes alongside each other. Codes that contain a common sub-string can be simplified, in turn simplifying the eventual regex output.


```{r}
#| label: remove_redundant
rr <- \(x, y, n = 1) {
  if (empty(x)) return(character(0))
  x <- x[stringfish::sf_substr(x, 1, n, nthreads = 4L) %notin% y]
  if (empty(x)) return(character(0))
  x
}

remove_redundant <- function(x) {

  c(x1, x2, x3, x4, x5) %<-% x
  
  list(
    x1 = x1,
    x2 = rr(x2, x1),
    x3 = rr(x3, x1) |> rr(x2, 2),
    x4 = rr(x4, x1) |> rr(x2, 2) |> rr(x3, 3),
    x5 = rr(x5, x1) |> rr(x2, 2) |> rr(x3, 3) |> rr(x4, 4)
  )
  
}
```

# Grouping

Groups each set of vectors into groupable regex patterns.

::: {.panel-tabset}

## Groups 1 & 2

```{r}
#| label: g1_g2
g1 <- function(x) {
  
  if (empty(x[["x1"]])) return(character(0))
  
  x[["x1"]]

}

g2 <- function(x) {
  
  if (empty(x[["x2"]])) return(character(0))
  
  collapse::rsplit(x[["x2"]], take(x[["x2"]]), use.names = FALSE)
  
}

hcpcs_tests |>
  split_lengths() |> 
  remove_redundant() |> 
  g1()

long_test2 |>
  split_lengths() |> 
  remove_redundant() |> 
  g1()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  g1()

hcpcs_tests |>
  split_lengths() |> 
  remove_redundant() |> 
  g2()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |>
  g2()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  g2()
```

## Groups 3-5

```{r}
#| label: g3
g3 <- function(x) {
  
  if (empty(x[["x3"]])) return(character(0))
  
  idx <- data.table(
    c1 = x[["x3"]],
    a1 = take(x[["x3"]]),
    a2 = take(x[["x3"]], 2),
    a3 = take(x[["x3"]], 3)) |> 
    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> 
    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> 
    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> 
    collapse::fcount(i1, add = TRUE, name = "G")

  orphans <- idx[i2 + i3 + G == 3, c1]
  idx     <- idx[c1 %notin% orphans]
    
  last <- collapse::fcount(idx, a1, a2) |> 
    dplyr::left_join(collapse::funique(
      idx[, .(a1, G)]), 
      by = dplyr::join_by(a1)) |> 
    dplyr::filter(N == G) |> 
    dplyr::right_join(
      idx[, .(c1, a1, a2)], 
      by = dplyr::join_by(a1, a2)) |> 
    dplyr::filter(!is.na(N))
  
  idx <- idx[c1 %notin% last$c1]

  out <- vctrs::vec_c(
    if (empty(orphans)) NULL else as.list(orphans),
    if (empty(last)) NULL else vctrs::vec_chop(last$c1, sizes = vctrs::vec_run_sizes(last$a1)),
    if (empty(idx)) NULL else vctrs::vec_chop(idx$c1, sizes = vctrs::vec_run_sizes(idx$a1))
  )
  
  if (empty(out)) return(character(0))

  return(out)
}

hcpcs_tests |>
  split_lengths() |> 
  remove_redundant() |>
  g3()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |>
  g3()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |>
  g3()
```

```{r}
#| label: g4
g4 <- function(x) {
  
  if (empty(x[["x4"]])) return(character(0))
  
  indices <- dplyr::tibble(
    code = x[["x4"]],
    a1 = take(code),
    a2 = take(code, 2),
    a3 = take(code, 3),
    a4 = take(code, 4)) |> 
    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> 
    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> 
    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> 
    dplyr::mutate(i4 = dplyr::consecutive_id(a4), .by = c(a1, a2, a3)) |> 
    collapse::fcount(i1, add = TRUE, name = "G")
  
  orphans <- indices[(indices$i2 + indices$i3 + indices$i4 + indices$G == 4), ]$code
    
  last <- fuimus::combine(indices[(!indices$code %in% orphans), c(1:5)], group_id, columns = c("a1", "a2"), sep = "")
    
  last <- collapse::fcount(last, group_id, a3) |> 
    dplyr::left_join(collapse::fcount(last, group_id, name = "G"), by = dplyr::join_by(group_id)) |> 
    dplyr::filter(N == G) |> 
    dplyr::right_join(last, by = dplyr::join_by(group_id, a3)) |> 
    dplyr::filter(!is.na(N))

  rest <- indices[(!indices$code %in% c(orphans, last$code)), ] |> 
    fuimus::combine(group_id, columns = c("a1", "a2", "a3"), sep = "")

  out <- vctrs::vec_c(
    if (empty(orphans)) NULL else as.list(orphans),
    if (empty(last)) NULL else vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$group_id)),
    if (empty(rest)) NULL else vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$group_id))
  )
  
  if (empty(out)) return(character(0))
  
  return(out)
}

hcpcs_tests[20:25] |> 
  split_lengths() |> 
  remove_redundant() |> 
  g4()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  g4()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |>
  g4()
```

```{r}
#| label: g5
g5 <- function(x) {
  
  if (empty(x[["x5"]])) return(character(0))
  
  indices <- dplyr::tibble(
    code = x[["x5"]],
    a1 = take(code),
    a2 = take(code, 2),
    a3 = take(code, 3),
    a4 = take(code, 4),
    a5 = take(code, 5)) |> 
    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> 
    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> 
    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> 
    dplyr::mutate(i4 = dplyr::consecutive_id(a4), .by = c(a1, a2, a3)) |> 
    dplyr::mutate(i5 = dplyr::consecutive_id(a5), .by = c(a1, a2, a3, a4)) |>
    collapse::fcount(i1, add = TRUE, name = "G")
  
  orphans <- indices[(indices$i2 + indices$i3 + indices$i4 + indices$i5 + indices$G == 5), ]$code
  
  last <- fuimus::combine(
    indices[(!indices$code %in% orphans), c(1:4, 6)], 
    group_id, columns = c("a1", "a2", "a3"), sep = "")
  
  last <- collapse::fcount(last, group_id, a5) |> 
    dplyr::left_join(collapse::fcount(last, group_id, name = "G"), by = dplyr::join_by(group_id)) |> 
    dplyr::filter(N == G) |> 
    dplyr::right_join(last, by = dplyr::join_by(group_id, a5)) |> 
    dplyr::filter(!is.na(N))

  rest <- indices[(!indices$code %in% c(orphans, last$code)), ] |> 
    fuimus::combine(group_id, columns = c("a1", "a2", "a3", "a4"), sep = "")

  out <- vctrs::vec_c(
    if (empty(orphans)) NULL else as.list(orphans),
    if (empty(last)) NULL else vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$group_id)),
    if (empty(rest)) NULL else vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$group_id))
  )
  
  if (empty(out)) return(character(0))
  
  return(out)
}

hcpcs_tests[26:30] |> 
  split_lengths() |> 
  remove_redundant() |> 
  g5()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  g4()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |>
  g5()
```

::: 

### Process Groups

```{r}
#| label: process_groups
process_groups <- function(x) {
  
  g <- x |> 
    split_lengths() |> 
    remove_redundant()
  
  list(
    g1 = g1(g),
    g2 = g2(g),
    g3 = g3(g),
    g4 = g4(g),
    g5 = g5(g)
  )
}

hcpcs_tests |> 
  process_groups() |> 
  lobstr::tree()

long_test2 |> 
  process_groups() |> 
  lobstr::tree()

all_tests |> 
  process_groups() |> 
  lobstr::tree()
```


### Internal 2

```{r}
#| label: internal_2
#| echo: true
#| eval: true
get_char <- \(x) x[stringfish::sf_grepl(x, "[A-Z]", nthreads = 4L)]
get_numb <- \(x) x[stringfish::sf_grepl(x, "[0-9]", nthreads = 4L)]

sort_order <- function(x) {
  
  sorted   <- stringr::str_sort(x, numeric = TRUE)
  alphabet <- get_char(sorted)
  numbers  <- get_numb(sorted)
  
  paste0(
    fuimus::collapser(alphabet), 
    fuimus::collapser(numbers)
    )
}
```

#### Reduce Runs

```{r}
#| label: reduce_runs
#| echo: true
#| eval: true
reduce_runs <- function(x) {
  
  if (x == "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") return("[A-Z0-9]")
  
  vec  <- rlang::set_names(rep(0, 36), c(LETTERS, 0:9))
  vec2 <- vec[fuimus::splitter(x)]
  vec2 <- vec2[!is.na(vec2)]
  vec[names(vec2)] <- 1

  vec_group <- dplyr::tibble(
    value = names(vec),
    key = vec,
    idx = seq_along(vec),
    group = dplyr::consecutive_id(key)) |>
    dplyr::mutate(group_size = dplyr::n(), .by = group) |>
    dplyr::filter(key == 1, group_size >= 3) |>
    dplyr::select(value, group)

  if (empty(vec_group)) return(x)
  
  xgroups <- vctrs::vec_chop(
    vec_group$value, 
    sizes = vctrs::vec_run_sizes(vec_group$group)) |>
    purrr::map(fuimus::collapser) |>
    purrr::list_c()
  
  replacements <- dplyr::left_join(
    dplyr::slice_min(vec_group, by = group, order_by = value) |> dplyr::rename(start = value),
    dplyr::slice_max(vec_group, by = group, order_by = value) |> dplyr::rename(end = value),
    by = dplyr::join_by(group)) |>
    glue::glue_data("{start}-{end}") |>
    as.vector()

  res <- stringi::stri_replace_all_regex(x, xgroups, replacements, vectorize_all = FALSE)

  paste0("[", res, "]")
}
```

## Groups of 1

```{r}
#| label: p1
p1 <- function(x) {
  
  if (empty(x[["g1"]])) return(NULL)
  
  re <- sort_order(x[["g1"]]) |> reduce_runs()
  
  if (re == "[A-Z0-9]") return(paste0("(^", re, "{5}$)"))
  
  return(paste0("(^", re, "[A-Z0-9]{4}$)"))
}

all_tests |> 
  process_groups() |> 
  p1()

hcpcs_tests |> 
  process_groups() |> 
  p1()

long_test2 |> 
  process_groups() |> 
  p1()

list(g1 = c(0:9, LETTERS)) |> 
  p1()
```

### Groups > 1

```{r}
#| label: p2
p2 <- function(x) {
  
  if (empty(x)) return(NULL)
  
  vecs <- stringr::str_split_fixed(
    x, "", collapse::fmax(collapse::vlengths(x))) |>
    as.data.frame()
  
  to_brackets <- vecs |>
    purrr::map(fuimus::uniq_rmna) |>
    purrr::map(sort_order)
  
  to_vec <- to_brackets |>
    purrr::map(reduce_runs)
  
  multi_chars <- unname(nchar(to_vec) > 1)
  
  nobrack <- stringr::str_detect(to_vec[multi_chars], "\\[|\\]", TRUE)
  
  to_vec[multi_chars] <- ifelse(
    any(nobrack), 
    purrr::map_chr(to_vec[multi_chars], \(x) paste0("[", x, "]")), 
    to_vec[multi_chars])

  purrr::list_c(to_vec) |> 
    fuimus::collapser()
}
```

### Reduce Groups

```{r}
#| label: reduce_groups
vrg <- function(x, n) {
  
  if (is.null(x)) return(NULL)
  
  postfix <- ifelse(
    stringfish::sf_starts(x, "[A-Z]", nthreads = 4L), 
    "[0-9]", "[A-Z0-9]")
  
  x <- ifelse(
    n == 0, 
    paste0("(^", x, "$)"),                
    paste0("(^", x, postfix, "{", n, "}$)")) 
    
  paste0(x , collapse = "|")
}

reduce_groups <- function(x) {
  
  list(
    g1 = p1(x),
    g2 = purrr::map_vec(x$g2, p2) |> vrg(3),
    g3 = purrr::map_vec(x$g3, p2) |> vrg(2),
    g4 = purrr::map_vec(x$g4, p2) |> vrg(1),
    g5 = purrr::map_vec(x$g5, p2) |> vrg(0)
  ) |> 
    purrr::compact() |> 
    paste0(collapse = "|")
}

all_tests |> 
  process_groups() |> 
  reduce_groups()

hcpcs_tests |> 
  process_groups() |>
  reduce_groups()

long_test2 |> 
  process_groups() |>
  reduce_groups()

long_test2[nchar(long_test2) > 4] |> 
  process_groups() |> 
  reduce_groups()
```


```{r}
#| label: final_output
medrex <- function(x) {
  x |> 
    process_groups() |> 
    reduce_groups()
}

medrex(all_tests)

# 7123
# vector_length(
#   vec_slice(
#     hcpcs_codes, 
#     sf_grepl(
#       hcpcs_codes, 
#       medrex(all_tests)
#       )
#     )
#   )

vec_slice(
  hcpcs_codes, 
  sf_grepl(
    hcpcs_codes, 
    medrex(
      long_test2[nchar(long_test2) > 3]
      )
    )
  )
```


{{< pagebreak >}}

::: {#nte-references .callout-tip collapse="true"}

## Links
### Reference

   - [Regex Cheatsheet](https://github.com/raredd/regex)
   - [Learn Regex](https://github.com/ziishaned/learn-regex)
   - [Evaluating strings as code](https://josiahparry.com/posts/2024-06-13-eval-strings)
   - [Building rules from code operands](https://github.com/Permian-Global-Research/rsi)
   - [Filter logic](https://github.com/atorus-research/ardis/blob/main/R/denom.R)
   - [Regular-Expression.info](https://www.regular-expressions.info/tutorial.html)
   - [RexEgg](https://www.rexegg.com/)
   - [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html)
   - [Debuggex](https://www.debuggex.com/)

### Packages

   - [**textshape**](https://github.com/trinker/textshape)
   - [**stringr.plus**](https://github.com/johncassil/stringr.plus)
   - [**regexmagic**](https://github.com/jonocarroll/regexmagic)
   - [**makeunique**](https://github.com/selkamand/makeunique)
   - [**similiars**](https://github.com/davidsjoberg/similiars)
   - [**strex**](https://github.com/rorynolan/strex/)
   - [**stringfish**](https://github.com/traversc/stringfish)
   - [**collapse**](https://sebkrantz.github.io/collapse/)
   - [**kit**](https://github.com/2005m/kit)
   - [**cheapr**](https://github.com/NicChr/cheapr)
   - [**fastplyr**](https://github.com/NicChr/fastplyr)
   - [**stringi**](https://stringi.gagolewski.com/)
   - [**qdapRegex**](https://github.com/trinker/qdapRegex)
   - [**charcuterie**](https://github.com/jonocarroll/charcuterie)

### Functions

   - [mark::globbing](https://github.com/jmbarbone/mark/blob/main/R/glob.R)
   - [RUtil::make_unique_comb](https://github.com/raivokolde/RUtil/blob/master/Source/R/make_unique_comb.r)
   - [mirmisc::longest_common_substring](https://github.com/mirvie/mirmisc/blob/main/R/utils.R)
   - [hutils::longest prefix/suffix](https://github.com/HughParsonage/hutils/blob/master/R/longest_affix.R)
   - [tidyext::combn_2_col](https://github.com/m-clark/tidyext/blob/master/R/combn_2_col.R)

::: 


# Session Information

```{r}
#| label: sessioninfo
#| echo: false
#| eval: true
sessioninfo::session_info(pkgs = "loaded", info = "packages")
```
