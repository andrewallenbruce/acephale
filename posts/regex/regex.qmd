---
title: "Learning to Love Regexes By Learning Them"
subtitle: "I Promised Myself I Wouldn't Do This Again"
description: "Building a regex generator for self-contained, well-defined string detection problems is a very effective way to learn regular expressions."
format:
  html:
    reference-location: margin
    other-links:
      - text: Regex Cheatsheet
        icon: bookmark-plus
        href: https://github.com/raredd/regex
      - text: RexEgg
        icon: bookmark-plus
        href: https://www.rexegg.com/
      - text: Regex in R
        icon: bookmark-plus
        href: https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| message: false
#| warning: false
#| echo: false
#| cache: false
knitr::opts_chunk$set(
  collapse  = FALSE,
  echo      = TRUE, 
  message   = FALSE, 
  warning   = FALSE,
  error     = TRUE,
  comment   = "",
  dpi       = 300, 
  dev       = "ragg_png",
  out.width = "100%",
  fig.align = "center",
  fig.width = 8
)
options(scipen = 999, digits = 2)

library(tidyverse)
library(rlang)
library(vctrs)
library(cli)
library(emphatic)
library(fuimus)
library(stringfish)
library(re2)
library(re2r)
library(compiler)
library(data.table)
library(tidyfast)
library(collapse)
library(cheapr)
library(fastplyr)

source(here::here("posts/regex/scripts", "data.R"))
```

# HCPCS

```{r}
#| label: hcpcs_all
#| echo: false
#| results: asis
rx <- list(
  all  = "(^[A-CEGHJ-MP-V0-9][0-9]{3}[AFMTU0-9]$)",
  iI   = "(^[0-9]{4}[AFMTU0-9]$)",
  cI   = "(^[0-9]{4}[AMU0-9]$)",
  cII  = "(^[0-9]{4}F$)",
  cIII = "(^[0-9]{4}T$)",
  iII  = "(^[A-CEGHJ-MP-V][0-9]{4}$)"
)

len <- \(rx) cheapr::vector_length(vctrs::vec_slice(hcpcs, stringfish::sf_grepl(hcpcs, rx, nthreads = 4L)))

data.frame(
  row.names = c("All", " Level I", "  Category I", "  Category II", "  Category III", " Level II"),
  Count = map_int(unlist(rx, use.names = FALSE), len), 
  Regex = unlist(rx, use.names = FALSE)) |> 
  hl(c("black", "grey20", "grey90", "grey90", "grey90", "grey20"), cols = 1) |>
  knit_print.emphatic()
```

# TODO

   * ~~If a **wildcard** begins with a **letter**, the *postfix* should be `[0-9]{n}`.~~
   * Eliminate `g1()` step in grouping.
   * In `remove_redundant()`, try pmap for `rr()` step.


## Checklist

-   [X] `split_lengths()`
-   [X] `remove_redundant()`
-   [ ] `process_groups()`
   -   [X] `g1()`
   -   [X] `g2()`
   -   [ ] `g3()`
   -   [ ] `g4()`
   -   [ ] `g5()`
-   [ ] `reduce_groups()`

# Helpers

```{r}
#| label: sort_order
sort_order <- \(x) {

  sort <- stringr::str_sort(x, numeric = TRUE)
  alph <- stringr::str_extract_all(sort, stringr::regex("[A-Z]"))
  numb <- stringr::str_extract_all(sort, stringr::regex("[0-9]"))
  alph <- purrr::list_c(alph)
  numb <- purrr::list_c(numb)

  paste0(
    paste0(alph, collapse = ""),
    paste0(numb, collapse = "")
  )
}
```


```{r}
#| label: helpers
# collapse
unique_vlength <- \(x) collapse::funique(collapse::vlengths(x, use.names = FALSE))
unique_narm    <- \(x) collapse::funique(collapse::na_rm(x))
max_vlength    <- \(x) collapse::fmax(collapse::vlengths(x, use.names = FALSE))

# vctrs
empty <- \(x) vctrs::vec_is_empty(x)
chop  <- \(v, g) vctrs::vec_chop(v, sizes = vctrs::vec_run_sizes(g))

# stringfish
take_at   <- \(x, i = 1) stringfish::sf_substr(x, start = i, stop = i, nthreads = 4L)
detect_az <- \(x) x[stringfish::sf_grepl(x, "[A-Z]{1}", nthreads = 4L)]
```

## View

```{r}
#| label: view
#| message: true
#| echo: true
cutoff <- \(x) stringr::str_trunc(string = x, width = 40, side = "right")
wrap   <- \(x) stringr::str_wrap(string = x, width = 60, exdent = 5, whitespace_only = FALSE)

view <- \(x) {
  idx  <- seq_along(x)
  len  <- collapse::vlengths(x, use.names = FALSE)
  tree <- unname(purrr::map_vec(x, paste0, collapse = " ")) |> purrr::map_vec(cutoff)
  
  cat(
    glue::glue(
      "{format(idx)}: ", 
      "{format(len)}|", 
      "--[{if (empty(tree)) NULL else format(tree, justify = 'none')}]"
      ),
    sep = "\n")
}

view_remove <- \(x) {
  
  len  <- length(x)
  tree <- unname(paste0(x, collapse = " ")) |> purrr::map_vec(cutoff)
  
  cat(
    glue::glue(
      "Removed ", 
      "{format(len, justify = 'left')}|", 
      "--[{if (empty(tree)) NULL else format(tree, justify = 'none')}]"
      ),
    sep = "\n")
}
```

# Preprocessing

## `split_lengths()`

```{r}
#| label: split_lengths
#| message: true
#| echo: true
split_lengths <- function(x, verbose = TRUE) {
  
  stopifnot(is.character(x))
  
  x <- stringfish::sf_gsub(x, "\\*|\\s", "", nthreads = 4L) |> 
    unique_narm() |> 
    stringr::str_sort()
  
  l <- collapse::vlengths(x)
  
  out <- list(
    x1 = x[l == 1],
    x2 = x[l == 2],
    x3 = x[l == 3],
    x4 = x[l == 4],
    x5 = x[l == 5])
  
  if (verbose) {
    
    cat("*  Split By Lengths:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}
codex::random_hcpcs(n = 5) |> 
  split_lengths()
```

## `remove_redundant()`

If a vector contains both `"A"` and `"A0"`, remove `"A0"`. Codes that contain a common sub-string can be simplified, in turn simplifying the eventual regex output.

```{r}
#| label: contrast
contrast <- \(long, short) {
  
  if (empty(long))  return(character(0))
  if (empty(short)) return(long)

  end <- unique_vlength(short)
  
  ldx <- stringfish::sf_substr(long, 1, end, nthreads = 4L)
  
  long[!ldx %in% short]
}
rr <- contrast
```

```{r}
#| label: remove_redundant
remove_redundant <- function(x, verbose = TRUE) {

  .c(x1, x2, x3, x4, x5) %=% x
  
  out <- list(
    x1 = x1,
    x2 = rr(x2, x1),
    x3 = rr(x3, x1) |> rr(x2),
    x4 = rr(x4, x1) |> rr(x2) |> rr(x3),
    x5 = rr(x5, x1) |> rr(x2) |> rr(x3) |> rr(x4)
  )
  
  if (verbose) {
    
    cat("<===||Remove Redundancies||:::||", sep = "\n")
    cat(view(out), sep = "\n")
    return(invisible(out))
    
  } else {
    return(out)
  }
}
codex::random_hcpcs(15) |> 
  split_lengths() |> 
  remove_redundant()
```

# Grouping

Group each set of vectors into regex patterns.

```{r}
#| label: lump
lump <- function(x, threshold = 3) {
  
  stopifnot(is.numeric(x))

  xo <- order(x)

  xs <- x[xo]
  
  dlag <- abs(c(0, xs[-1] - xs[seq_along(xs) - 1]))

  bi <- ifelse(dlag >= threshold, 1, 0)

  id <- cumsum(bi) + 1
  
  id[xo]
}
```

```{r}
#| label: letters_2_numbers
letters_2_numbers <- \(x) {
  
  look <- rlang::set_names(
    seq_along(LETTERS), 
    LETTERS)
  
  unname(look[detect_az(x)])
}
```


::: {.panel-tabset}

## [g1|g2]

```{r}
#| label: g1_g2
g1 <- function(x, verbose = TRUE) {
  
  x <- collapse::get_elem(x, "x1")
  
  if (empty(x)) return(character(0))
  
  out <- list(x)
  
  if (verbose) {
    
    cat("** Group 1:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}

g2 <- function(x, verbose = TRUE) {
  
  x <- collapse::get_elem(x, "x2")
  
  if (empty(x)) return(character(0))
  
  out <- collapse::rsplit(x, take_at(x, 1), use.names = FALSE)
  
  if (verbose) {
    
    cat("** Group 2:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}

codex::random_hcpcs() |> 
  split_lengths() |> 
  remove_redundant() |>
  g1()

codex::random_hcpcs(25) |>
  split_lengths() |> 
  remove_redundant() |> 
  g2()
```

## [g3]

```{r}
x <- all_tests[nchar(all_tests) == 3] |> 
  split_lengths() |> 
  remove_redundant()

x <- codex::random_hcpcs(25) |> 
  split_lengths() |> 
  remove_redundant()

group_hcpcs_3 <- function(x) {

  x <- collapse::get_elem(x, "x3")
  
  if (empty(x)) return(character(0))

  indices <- data.table::data.table(
    code = x,
    group_id = stringfish::sf_substr(x, 1, 2, nthreads = 4L),
    a1 = take_at(x, 1),
    a2 = take_at(x, 2),
    a3 = take_at(x, 3),
    i1 = data.table::rleid(take_at(x, 1))) |>
    dplyr::mutate(i2 = data.table::rleid(a2), .by = a1) |>
    dplyr::mutate(i3 = data.table::rleid(a3), .by = c(a1, a2))

  orphans <- indices |>
    dplyr::add_count(i1) |>
    dplyr::filter((i2 + i3 + n) == 3) |>
    dplyr::pull(code)

  last <- indices[code %notin% orphans]

  last <- dplyr::left_join(
    last |> dplyr::count(group_id, a2),
    last |> dplyr::count(group_id, name = "g"),
    by = dplyr::join_by(group_id)) |>
    dplyr::filter(n == g) |>
    dplyr::right_join(last, by = dplyr::join_by(group_id, a2)) |>
    dplyr::filter(!is.na(n))

  rest <- indices |>
    dplyr::filter(!code %in% c(orphans, dplyr::pull(last, code))) |>
    fuimus::combine(group_id, columns = c("a1", "a2"), sep = "")

  grouped <- vctrs::vec_c(
    as.list(orphans),
    vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$group_id)),
    vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$group_id))
  )
  grouped[collapse::radixorderv(collapse::vlengths(grouped), sort = TRUE)]
}
```


```{r}
#| label: g3
g3 <- function(x, verbose = TRUE) {
  
  x <- collapse::get_elem(x, "x3")
  
  if (empty(x)) return(character(0))
  
  chr <- detect_az(x)
  num <- x[!x %in% chr]
  
  num <- data.table::data.table(
    code = num, 
    lump = lump(as.integer(num)))
  
  chr <- data.table::data.table(
    code = chr, 
    lump = lump(as.integer(stringr::str_replace_all(chr, "[A-Z]", letters_2_numbers))))
  
  out <- vctrs::vec_c(
    if (empty(num)) NULL else chop(num$code, num$lump),
    if (empty(chr)) NULL else chop(chr$code, chr$lump))
  
  if (empty(out)) return(character(0))

  if (verbose) {
    
    cat("** Group 3:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}

all_tests[nchar(all_tests) < 3] |> 
  split_lengths() |> 
  remove_redundant() |>
  g3()

all_tests[nchar(all_tests) == 3] |> 
  split_lengths() |> 
  remove_redundant() |>
  g3()

codex::random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |>
  g3()
```

## [4]

```{r}
#| label: g4
g4 <- function(x, verbose = TRUE) {
  
  x <- collapse::get_elem(x, "x4")
  
  if (empty(x)) return(character(0))
  
  chr <- detect_az(x)
  num <- x[!x %in% chr]
  
  num <- data.table::data.table(code = num, lump = lump(as.integer(num)))
  
  chr <- data.table::data.table(
    code = chr, 
    lump = lump(
      as.integer(
        stringr::str_replace_all(chr, "[A-Z]", letters_2_numbers)
        )))
  
  out <- vctrs::vec_c(
    if (empty(num)) NULL else chop(num$code, num$lump),
    if (empty(chr)) NULL else chop(chr$code, chr$lump))
  
  if (empty(out)) return(character(0))
  
  if (verbose) {
    
    cat("** Group 4:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}

hcpcs_tests[20:25] |> 
  split_lengths() |> 
  remove_redundant() |> 
  g4()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |>
  g4()

codex::random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |>
  g4()
```

## [5]

```{r}
#| label: g5
g5 <- function(x, verbose = TRUE) {
  
  x <- collapse::get_elem(x, "x5")
  
  if (empty(x)) return(character(0))
  
  chr <- detect_az(x)
  num <- x[!x %in% chr]
  
  num  <- data.table::data.table(code = num, lump = lump(as.integer(num)))
  
  chr <- data.table::data.table(
    code = chr, 
    lump = lump(
      as.integer(
        stringr::str_remove_all(chr, "[A-Z]")
        )))
  
  out <- vctrs::vec_c(
    if (empty(num)) NULL else chop(num$code, num$lump),
    if (empty(chr)) NULL else chop(chr$code, chr$lump))
  
  if (empty(out)) return(character(0))
  
  if (verbose) {
    
    cat("** Group 5:", sep = "\n")
    cat(view(out), sep = "\n")  
    return(invisible(out))
    
  } else {
    return(out)
  }
}

hcpcs_tests[26:30] |> 
  split_lengths() |> 
  remove_redundant() |>
  g5()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |>
  g5()

new_test |>
  split_lengths() |> 
  remove_redundant() |>
  g5()

codex::random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |>
  g5()
```

::: 

# Process Groups

```{r}
#| label: process_groups
process_groups <- function(x, verbose = TRUE) {
  
    out <- list(
      g1 = g1(x, verbose = verbose),
      g2 = g2(x, verbose = verbose),
      g3 = g3(x, verbose = verbose),
      g4 = g4(x, verbose = verbose),
      g5 = g5(x, verbose = verbose)
      )
  
  if (verbose) {
    return(invisible(out))
  } else {
    return(out)
  }
}

hcpcs_tests |>
  split_lengths() |> 
  remove_redundant() |> 
  process_groups()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups()

all_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups()

codex::random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |>
  process_groups()
```

## Reduce Runs

```{r}
#| label: reduce_runs
#| echo: true
#| eval: true
reduce_runs <- function(x) {
  
  ad <- c(LETTERS, 0:9)
  
  # if (x == paste0(ad, collapse = "")) return("[A-Z0-9]")
  
  vec  <- rlang::set_names(rep(0, 36), ad)
  
  vec2 <- vec[fuimus::splitter(x)]
  
  vec2 <- vec2[!is.na(vec2)]
  
  vec[names(vec2)] <- 1

  vec_group <- dplyr::tibble(
    value = names(vec),
    key = vec,
    idx = seq_along(vec),
    group = dplyr::consecutive_id(key)) |>
    dplyr::mutate(group_size = dplyr::n(), .by = group) |>
    dplyr::filter(key == 1, group_size >= 3) |>
    dplyr::select(value, group)

  if (empty(vec_group)) return(x)
  
  xgroups <- chop(vec_group$value, vec_group$group) |>
    purrr::map(fuimus::collapser) |>
    purrr::list_c()
  
  replacements <- dplyr::left_join(
    dplyr::slice_min(vec_group, by = group, order_by = value) |> dplyr::rename(start = value),
    dplyr::slice_max(vec_group, by = group, order_by = value) |> dplyr::rename(end = value),
    by = dplyr::join_by(group)) |>
    glue::glue_data("{start}-{end}") |>
    as.vector()

  res <- stringi::stri_replace_all_regex(x, xgroups, replacements, vectorize_all = FALSE)

  paste0("[", res, "]")
}
```

## G == 1

```{r}
#| label: p1
p1 <- function(x) {
  
  if (empty(x[["g1"]])) return(character(0))
  
  g1 <- collapse::get_elem(x, "g1")[[1]]
  
  re <- sort_order(g1) |> reduce_runs()
  
  if (re == "[A-Z0-9]") return(paste0("^", re, "{5}$"))
  
  postfix <- ifelse(
    stringfish::sf_grepl(re, "^\\[?[A-Z]\\-?", nthreads = 4L), "[0-9]", "[A-Z0-9]")
  
  glue::glue("^{re}{postfix}{{4}}$")
}

hcpcs_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  p1()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  p1()

list(g1 = c(0:9, LETTERS)) |> p1()

list(g1 = c(LETTERS[1:5], 0:9)) |> p1()
```

## G > 1

```{r}
#| label: p2
p2 <- function(x) {
  
  if (empty(x)) return(character(0))
  
  vec <- stringr::str_split_fixed(x, "", max_vlength(x)) |> 
    as.data.frame() |> 
    purrr::map(unique_narm) |> 
    purrr::map(sort_order) |>
    purrr::map(reduce_runs)
  
  multi <- unname(nchar(vec) > 1)
  
  nobrack <- stringr::str_detect(vec[multi], "\\[|\\]", TRUE)
  
  vec[multi] <- ifelse(any(nobrack), purrr::map_chr(vec[multi], \(x) paste0("[", x, "]")), vec[multi])

  paste0(purrr::list_c(vec), collapse = "")
}
```

# Reduce Groups

```{r}
#| label: reduce_groups
#| message: false
#| error: true
vec_to_regex <- function(x, n) {
  
  if (empty(x)) return(character(0))
  
  postfix <- ifelse(
    stringfish::sf_grepl(
      x, "^\\[?[A-Z]\\-?", nthreads = 4L), 
    "[0-9]", "[A-Z0-9]")
  
  x <- data.table::fcase(
    n == 0, paste0("^", x, "$"),                
    n == 1, paste0("^", x, postfix, "$"),
    default = paste0("^", x, postfix, "{", n, "}$"))
    
  paste0(x , collapse = "")
}

vrg <- vec_to_regex

reduce_groups <- function(x) {
  
  list(
    g1 = p1(x),
    g2 = purrr::map_chr(x$g2, p2) |> purrr::map_chr(vrg, n = 3),
    g3 = purrr::map_chr(x$g3, p2) |> purrr::map_chr(vrg, n = 2),
    g4 = purrr::map_chr(x$g4, p2) |> purrr::map_chr(vrg, n = 1),
    g5 = purrr::map_chr(x$g5, p2) |> purrr::map_chr(vrg, n = 0)
  )
}

all_tests[nchar(all_tests) > 2] |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

hcpcs_tests |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

long_test2 |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

# long_test2[nchar(long_test2) == 4]

new_test |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()

codex::random_hcpcs(30) |> 
  split_lengths() |> 
  remove_redundant() |> 
  process_groups() |> 
  reduce_groups()
```

# `medrex()`

```{r}
#| label: final_output
#| message: false
#| error: true
medrex <- function(x, verbose = TRUE) {
  x |> 
    split_lengths(verbose = verbose) |> 
    remove_redundant(verbose = verbose) |> 
    process_groups(verbose = verbose) |> 
    reduce_groups() |> 
    unlist(use.names = FALSE) |> 
    glue::glue_collapse(sep = "|")
}

long_test2[nchar(long_test2) > 4]

# REMOVE {1} FROM EXPRS WITH 5 CHARS

medrex(long_test2[nchar(long_test2) > 4])

vctrs::vec_slice(
  hcpcs, 
  stringfish::sf_grepl(
    hcpcs, 
    medrex(
      long_test2[nchar(long_test2) > 4],
      verbose = FALSE
      )
    )
  )
```


{{< pagebreak >}}

::: {#nte-references .callout-tip collapse="true"}

## Links
### Reference

   - [Regex Cheatsheet](https://github.com/raredd/regex)
   - [Learn Regex](https://github.com/ziishaned/learn-regex)
   - [Evaluating strings as code](https://josiahparry.com/posts/2024-06-13-eval-strings)
   - [Building rules from code operands](https://github.com/Permian-Global-Research/rsi)
   - [Filter logic](https://github.com/atorus-research/ardis/blob/main/R/denom.R)
   - [Regular-Expression.info](https://www.regular-expressions.info/tutorial.html)
   - [RexEgg](https://www.rexegg.com/)
   - [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html)
   - [Debuggex](https://www.debuggex.com/)

### Packages

   - [**textshape**](https://github.com/trinker/textshape)
   - [**stringr.plus**](https://github.com/johncassil/stringr.plus)
   - [**regexmagic**](https://github.com/jonocarroll/regexmagic)
   - [**makeunique**](https://github.com/selkamand/makeunique)
   - [**similiars**](https://github.com/davidsjoberg/similiars)
   - [**strex**](https://github.com/rorynolan/strex/)
   - [**stringfish**](https://github.com/traversc/stringfish)
   - [**collapse**](https://sebkrantz.github.io/collapse/)
   - [**kit**](https://github.com/2005m/kit)
   - [**cheapr**](https://github.com/NicChr/cheapr)
   - [**fastplyr**](https://github.com/NicChr/fastplyr)
   - [**stringi**](https://stringi.gagolewski.com/)
   - [**qdapRegex**](https://github.com/trinker/qdapRegex)
   - [**charcuterie**](https://github.com/jonocarroll/charcuterie)

### Functions

   - [mark::globbing](https://github.com/jmbarbone/mark/blob/main/R/glob.R)
   - [RUtil::make_unique_comb](https://github.com/raivokolde/RUtil/blob/master/Source/R/make_unique_comb.r)
   - [mirmisc::longest_common_substring](https://github.com/mirvie/mirmisc/blob/main/R/utils.R)
   - [hutils::longest prefix/suffix](https://github.com/HughParsonage/hutils/blob/master/R/longest_affix.R)
   - [tidyext::combn_2_col](https://github.com/m-clark/tidyext/blob/master/R/combn_2_col.R)

::: 


## Session Information 

```{r}
#| echo: false
pander::pander(sessionInfo())
```
