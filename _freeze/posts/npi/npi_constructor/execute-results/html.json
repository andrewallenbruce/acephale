{
  "hash": "24357ce1099596cf6658f2403327b9ff",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"NPIs & Luhn's Algorithm\"\nsubtitle: \"Step-by-step National Provider Identifier Validation with Luhn's Algorithm\"\ndescription: \"Experimenting with the CMS standard for NPI validation.\"\nformat:\n  html:\n    reference-location: margin\n    other-links:\n      - text: Luhn Algorithm\n        icon: bookmark-plus\n        href: https://en.wikipedia.org/wiki/Luhn_algorithm\n      - text: ISO/IEC 7812\n        icon: bookmark-plus\n        href: https://en.wikipedia.org/wiki/ISO/IEC_7812\n      - text: CMS NPI Standard\n        icon: bookmark-plus\n        href: https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf\n      - text: CMS-10114 NPI Application\n        icon: bookmark-plus\n        href: https://www.cms.gov/medicare/cms-forms/cms-forms/downloads/cms10114.pdf\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\nA **National Provider Identifier (NPI)** is a unique 10-digit identification number assigned to health care providers in the United States through NPPES^[The National Plan and Provider Enumeration System. This includes the NPI Registry, a free directory of all active NPI records.] The Centers for Medicare & Medicaid Services (CMS) developed the NPI as a way to standardize the identification of health care providers across the health care industry.\n\n# CMS NPI Standard {#sec-cmsstandard}\n\nThe following is an excerpt from the CMS document on the NPI check digit calculation, [Requirements for National Provider Identifier (NPI) and NPI Check Digit (2004-01-23)](https://www.cms.gov/Regulations-and-Guidance/Administrative-Simplification/NationalProvIdentStand/Downloads/NPIcheckdigit.pdf).\n\n### NPI Requirements {#sec-requirements}\n|                              |                                                                                     |\n|------------------------------|-------------------------------------------------------------------------------------|\n| {{< mi wrong_location size=60px >}}    | Consists of **10** numeric digits, the 10<sup>th</sup> being the check digit. |\n| {{< mi password size=60px >}}       | Has no embedded intelligence.                                                      |\n| {{< mi dialpad size=60px >}}  | Begins with a `1` or `2`.^[Use of other first digits for the NPI must be coordinated with the use of first digits by the standard health plan identifier, when it is adopted.] |\n| {{< mi pattern size=60px >}}           | Generated by a scattering algorithm using all possible numeric combinations.     |\n| {{< mi fingerprint size=60px >}}       | Be unique, without requiring database access for verification.                      |\n\n## NPI Check Digit {#sec-checkdigit}\n\nThe check digit is calculated using the [Luhn formula](https://en.wikipedia.org/wiki/Luhn_algorithm) for computing the modulus 10 *double-add-double* check digit.^[Recognized as an ISO standard (ISO/IEC 7812) and is the specified check digit algorithm to be used for the card issuer identifier on a standard health identification card.]\n\nWhen an NPI is used as a card issuer identifier on a standard health identification card, it is prefixed with **80840**, in which **80** indicates *health applications* and **840** indicates the *United States*.\nTo enable this feature for any NPI, the check digit will always be calculated as if the prefix is present. For a non-prefixed NPI, this is accomplished by adding the constant **24** in step 2 of the calculation.\n\n### Check Digit Calculation\n\nThe calculation is as follows:\n\n   1. Beginning with the rightmost digit, double the value of the alternate digits.\n   \n   1. Add the individual digits of the products from Step 1 to the unaffected digits from the original number.\n   \n   1. Subtract the result of step 2 from the next highest number ending in zero. This is the check digit.\n\n\n::: {#note-mod .callout-note}\n\n### Next Multiple of Ten\n\nThe *next highest number ending in zero* is the next multiple of ten. \n\nSpecifically, for some number $n$, the next multiple of ten would be $n + (10 - (n \\mod 10))$:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnext_10 <- \\(n) n + (10 - (n %% 10))\n```\n:::\n\n\n\n\nFor example, if $n$ is `23`, the next multiple of ten is `30`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnext_10(23)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n:::\n\n\n\n\nIf $n$ is a multiple of ten, such as `50`, the next multiple of 10 is `60`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnext_10(50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 60\n```\n\n\n:::\n:::\n\n\n\n\n\n::: \n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n#### Examples\n\nThe following check digit calculation examples are reproduced from the CMS Standard document, which includes demonstrations for both prefixed and non-prefixed NPIs.\n\n::: {.panel-tabset}\n\n## Prefix\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npre = c(8, 0, 8, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nrev = c(8, 0, 8, 8, 0, 2, 2, 6, 4, 10, 6, 14, 8, 18)\nadd = quote(8 + 0 + 8 + 8 + 0 + 2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8)\neq  = 67\n```\n:::\n\n\n\n\n\nAssume the prefixed 9-position identifier is:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprefix <- \\(x) {\n  as.integer(\n    unlist(\n      strsplit(\n        paste0(80840, x), \"\")\n      )\n    )\n}\n\nprefix(123456789)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 8 0 8 4 0 1 2 3 4 5 6 7 8 9\n```\n\n\n:::\n:::\n\n\n\n\nBeginning on the right, double the alternate digits:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreverse_double <- \\(x) {\n  \n  x <- rev(x)\n  \n  idx <- c(1, 3, 5, 7, 9, 11, 13)\n  \n  x[idx] <- x[idx] * 2\n  \n  rev(x)\n}\n\n\nprefix(123456789) |> \n  reverse_double()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  8  0  8  8  0  2  2  6  4 10  6 14  8 18\n```\n\n\n:::\n:::\n\n\n\n\nSum the **individual** digits:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nadd_digits <- \\(x) {\n  sum(\n    as.integer(\n      unlist(\n        strsplit(\n          as.character(x), \"\")\n        )\n      )\n    )\n}\n\nprefix(123456789) |> \n  reverse_double() |> \n  add_digits()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 67\n```\n\n\n:::\n:::\n\n\n\n\nSubtract the sum from the next multiple of 10. \nThis is the check digit: `70 – 67 = 3`\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncheck_digit <- \\(x) {\n  ceiling(x / 10) * 10 - x\n}\n\nprefix(123456789) |> \n  reverse_double() |> \n  add_digits() |>\n  check_digit()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nAppend the check digit to the identifier: `808401234567893`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nappend_check <- \\(check, id) {\n  cat(\n    paste0(\n      paste0(\n        prefix(id), \n        collapse = \"\"), \n      check)\n    )\n}\n\nprefix(123456789) |> \n  reverse_double() |> \n  add_digits() |>\n  check_digit() |> \n  append_check(123456789)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n808401234567893\n```\n\n\n:::\n:::\n\n\n\n\n## Non-Prefix\n\n> Assume the non-prefixed \n> 9-position identifier \n> is `123456789`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsplit_id <- \\(x) {\n  as.integer(\n    unlist(\n      strsplit(\n        as.character(x), \"\"\n        )\n      )\n    )\n}\n\nx <- split_id(123456789)\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6 7 8 9\n```\n\n\n:::\n:::\n\n\n\n\n> Beginning on the right, \n> double the alternate digits:\n> `2  2  6  4 10  6 14  8 18`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreverse_double <- \\(x) {\n  \n  x <- rev(x)\n  \n  idx <- c(1, 3, 5, 7, 9)\n  \n  x[idx] <- x[idx] * 2\n  \n  rev(x)\n}\n\nx <- reverse_double(x)\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  2  6  4 10  6 14  8 18\n```\n\n\n:::\n:::\n\n\n\n\n> Add constant 24 to the sum of the individual digits: \n> `2 + 2 + 6 + 4 + 1 + 0 + 6 + 1 + 4 + 8 + 1 + 8 + 24 = 67`\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsum_plus_24 <- \\(x) {\n  sum(\n    as.integer(\n      unlist(\n        strsplit(\n          as.character(x), \"\")\n        )\n      )\n    ) + 24\n}\n\nx <- sum_plus_24(x)\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 67\n```\n\n\n:::\n:::\n\n\n\n\n> Subtract the sum from the next multiple of 10. \n> This is the check digit: `70 – 67 = 3`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncheck_digit <- \\(x) {\n  ceiling(x / 10) * 10 - x\n}\n\nx <- check_digit(x)\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n> Append the check digit to \n> the identifier: `1234567893`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nappend_check <- \\(id, check) {\n  cat(paste0(id, check))\n}\n\nappend_check(123456789, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1234567893\n```\n\n\n:::\n:::\n\n\n\n\n::: \n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n# Function Goals {#sec-goals}\n\nI want to build a function that constructs a valid NPI from a 10-digit NPI \"candidate.\" The function should print the validation steps to the console. \nIf the input is syntactically valid, it should return the original NPI invisibly along with a `success!` message. If invalid, it should return the valid NPI with a `warning!` message.\n\nThere should also be a `verbose` option to silence the messages and return only the valid NPI. And finally, a minimal version that simply returns `TRUE` or `FALSE`.\n\n\n## Validating the Input\n   \n   * Input string (`x`) validation order:\n      + Abort if not `length(x) == 1`\n      + Abort if not 10 characters long\n      + Abort if any elements of `x` are not `0-9`\n      + Abort if first element is not `\"1\"` or `\"2\"`\n      + Coerce to `<character>` if `x` is a `<numeric>` vector\n\n\n\n\n::: {.cell layout-align=\"center\" filename='input_validation.R'}\n\n```{.r .cell-code}\n# Abort if `x` is `length(x) != 1`\ncheck_length <- function(x) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  if (length(x) != 1) {\n    cli::cli_abort(\n      \"{.arg {arg}} must be of length 1.\", \n      arg = arg, \n      call = call,\n      class = \"check_length\"\n      )\n  }\n}\n\n# If `x` is a `<numeric>` \n# vector, coerce to `<character>`\nnumeric_to_char <- function(x) {\n  if (!rlang::is_character(x)) { \n    as.character(x)\n  } else {\n    x  \n  }\n}\n\n# Abort if any of `x`'s \n# elements are not numbers\ncheck_chars_numeric <- function(x) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  if (!stringfish::sf_grepl(x, \"^[0-9]{1,10}$\")) {\n    cli::cli_abort(\n      \"An {.arg {arg}} must contain numbers only.\", \n      arg = arg, \n      call = call,\n      class = \"check_chars_numeric\"\n      )\n  }\n}\n\n# Abort if `x` is not \n# 10 characters long\ncheck_nchars_10 <- function(x) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  if (stringfish::sf_nchar(x) != 10L) {\n    cli::cli_abort(\n      \"An {.arg {arg}} must be 10 characters long.\", \n      arg = arg, \n      call = call,\n      class = \"check_nchars_10\"\n      )\n  }\n}\n\n# Must begin with 1 or 2\ncheck_first_char <- function(x) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  if (!stringfish::sf_substr(x, 1, 1) %in% c(\"1\", \"2\")) {\n    cli::cli_abort(\n      \"An {.arg {arg}} must start with a 1 or 2.\", \n      arg = arg, \n      call = call,\n      class = \"check_first_char\"\n      )\n  }\n}\n```\n:::\n\n\n\n\n## CLI Messages\n\n\n\n\n::: {.cell layout-align=\"center\" filename='cli_messages.R'}\n\n```{.r .cell-code}\nnpi_inform <- function(x, msg) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  rlang::inform(\n    message = (\n      c(\"*\" = glue::glue(\"{msg}: {x}\"))),\n    use_cli_format = TRUE,\n    arg = arg,\n    call = call,\n    class = \"npi_inform\"\n  )\n}\n\nnpi_alert_invalid <- function(x, y) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  rlang::inform(\n    message = (c(\"x\" = \"NPI is invalid\")),\n    body = (c(\"!\" = glue::glue(\"{x} != {y}\"))),\n    use_cli_format = TRUE,\n    arg = arg,\n    call = call,\n    class = \"npi_alert_invalid\"\n  )\n}\n\nnpi_alert_valid <- function(x, y) {\n  \n  arg  <- rlang::caller_arg(x)\n  call <- rlang::caller_env()\n  \n  rlang::inform(\n    message = (c(\"v\" = \"NPI is valid\")),\n    body = (c(\">\" = glue::glue(\"{x} == {y}\"))),\n    use_cli_format = TRUE,\n    arg = arg,\n    call = call,\n    class = \"npi_alert_valid\"\n  )\n}\n```\n:::\n\n\n\n\n## Constructor Function\n\n\n\n\n::: {.cell layout-align=\"center\" filename='npi_constructor.R'}\n\n```{.r .cell-code}\nnpi_constructor <- function(npi, verbose = TRUE) {\n  \n  npi <- numeric_to_char(npi)\n  check_length(npi)\n  check_nchars_10(npi)\n  check_chars_numeric(npi)\n  check_first_char(npi)\n  \n  p <- \\(..., ss = \"\") paste0(..., collapse = ss)\n  s <- \\(x) unlist(strsplit(x, \"\"), use.names = FALSE)\n  \n  id <- rev(s(npi)[1:9])\n  \n  if (verbose) {\n    npi_inform(npi, \"Testing NPI candidate\")\n    npi_inform(p(id, ss = \"\"), \"Reverse 9-digit identifier\")\n  }\n  \n  idx     <- c(1, 3, 5, 7, 9)\n  id      <- as.numeric(id)\n  id[idx] <- as.numeric(id[idx]) * 2\n  id[idx] <- ifelse(id[idx] > 9, id[idx] - 9, id[idx])\n  \n  if (verbose) {\n    npi_inform(p(id, ss = \" \"), \"Double & reduce alternates\")\n  }\n  \n  id   <- sum(id)\n  cn   <- id + 24\n  ml   <- ceiling(cn / 10) * 10\n  ck   <- ml - cn\n  test <- substr(npi, 1, 9)\n  test <- p(test, ck)\n  \n  if (verbose) {\n    \n    npi_inform(p(p(c(id, 24), ss = \" + \"), p(\" = \", cn)), \"Add 24 to sum digits\")\n    npi_inform(p(p(\"⌈\", cn, \"⌉\"), p(\" = \", ml)) ,\"Next multiple of 10\")\n    npi_inform(p(p(c(ml, cn), ss = \" - \"), p(\" = \", ck)), \"Find check digit\")\n    npi_inform(p(test, ss = \"\"), \"Append check digit\")\n    \n    if (identical(test, npi)) npi_alert_valid(test, npi)\n    if (!identical(test, npi)) npi_alert_invalid(test, npi)\n  }\n  invisible(test)\n}\n```\n:::\n\n\n\n\n#### Test Validations\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnpi_constructor(\"123456789\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `npi_constructor()`:\n! An `npi` must be 10 characters long.\n```\n\n\n:::\n\n```{.r .cell-code}\nnpi_constructor(\"O123456789\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `npi_constructor()`:\n! An `npi` must contain numbers only.\n```\n\n\n:::\n\n```{.r .cell-code}\nnpi_constructor(\"0000000000\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `npi_constructor()`:\n! An `npi` must start with a 1 or 2.\n```\n\n\n:::\n:::\n\n\n\n\n#### Test Verbose Output\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnpi_constructor(1234567891)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Testing NPI candidate: 1234567891\n• Reverse 9-digit identifier: 987654321\n• Double & reduce alternates: 9 8 5 6 1 4 6 2 2\n• Add 24 to sum digits: 43 + 24 = 67\n• Next multiple of 10: ⌈67⌉ = 70\n• Find check digit: 70 - 67 = 3\n• Append check digit: 1234567893\n✖ NPI is invalid\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnpi_constructor(1043477615)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Testing NPI candidate: 1043477615\n• Reverse 9-digit identifier: 167743401\n• Double & reduce alternates: 2 6 5 7 8 3 8 0 2\n• Add 24 to sum digits: 41 + 24 = 65\n• Next multiple of 10: ⌈65⌉ = 70\n• Find check digit: 70 - 65 = 5\n• Append check digit: 1043477615\n✔ NPI is valid\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnpi_constructor(\"1000000000\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Testing NPI candidate: 1000000000\n• Reverse 9-digit identifier: 000000001\n• Double & reduce alternates: 0 0 0 0 0 0 0 0 2\n• Add 24 to sum digits: 2 + 24 = 26\n• Next multiple of 10: ⌈26⌉ = 30\n• Find check digit: 30 - 26 = 4\n• Append check digit: 1000000004\n✖ NPI is invalid\n```\n\n\n:::\n:::\n\n\n\n\n#### Test Verbose Option/Invisible Return\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnpi_constructor(\"1000000000\", verbose = FALSE)\n\nnew_npi <- npi_constructor(\"1000000000\", verbose = FALSE)\n\nnew_npi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1000000004\"\n```\n\n\n:::\n:::\n\n{{< pagebreak >}}\n\n\n\n\n\n\n## Minimal Validator\n\n\n\n\n::: {.cell layout-align=\"center\" filename='is_valid_npi.R'}\n\n```{.r .cell-code}\nsmash <- \\(...) paste0(..., collapse = \"\")\nsplat <- \\(x)   unlist(strsplit(x, \"\"), use.names = FALSE)\nidx   <- c(1, 3, 5, 7, 9)\n\nis_valid_npi <- function(x) {\n  \n  stopifnot(stringfish::sf_grepl(x, \"^[12][0-9]{9}$\"))\n  \n  id <- as.numeric(cheapr::cheapr_rev(splat(x)[1:9]))\n  \n  id[idx] <- id[idx] * 2\n  \n  id[idx] <- codex::iif_else(id[idx] > 9, id[idx] - 9, id[idx])\n  \n  id   <- sum(id) + 24\n  ck   <- (ceiling(id / 10) * 10) - id\n  test <- smash(codex::sf_sub(x, start = 1, stop = 9), ck)\n  \n  identical(test, x)\n}\n```\n:::\n\n\n\n\n#### Test Validator\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis_valid_npi(\"123456789\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in is_valid_npi(\"123456789\"): stringfish::sf_grepl(x, \"^[12][0-9]{9}$\") is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_valid_npi(\"O123456789\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in is_valid_npi(\"O123456789\"): stringfish::sf_grepl(x, \"^[12][0-9]{9}$\") is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_valid_npi(\"0000000000\") # All leading zeroes will be dropped\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in is_valid_npi(\"0000000000\"): stringfish::sf_grepl(x, \"^[12][0-9]{9}$\") is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_valid_npi(\"3000000000\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in is_valid_npi(\"3000000000\"): stringfish::sf_grepl(x, \"^[12][0-9]{9}$\") is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_valid_npi(\"1043477615\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis_valid_npi(\"1234567891\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrandom_npi_generator <- \\(n) {\n  stringfish::sf_convert(\n    replicate(\n    n = n, \n    expr = paste0(\n      c(sample(1:2, 1, replace = TRUE), \n        sample(0:9, 9, replace = TRUE)), \n      collapse = \"\")))\n}\n\nrandom_npi_generator(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2003036483\" \"2543498492\" \"1419330191\"\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn <- 100000\nx <- random_npi_generator(n)\ny <- x[purrr::map_lgl(x, is_valid_npi)]\n\ncat((length(y) / n) * 100, \"%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10.067 %\n```\n\n\n:::\n\n```{.r .cell-code}\nbench::mark(purrr::map_lgl(x, is_valid_npi)) |> \n  dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1\nColumns: 13\n$ expression <bch:expr> <purrr::map_lgl(x, is_valid_npi)>\n$ min        <bch:tm> 18.9s\n$ median     <bch:tm> 18.9s\n$ `itr/sec`  <dbl> 0.05301521\n$ mem_alloc  <bch:byt> 2.38MB\n$ `gc/sec`   <dbl> 1.696487\n$ n_itr      <int> 1\n$ n_gc       <dbl> 32\n$ total_time <bch:tm> 18.9s\n$ result     <list> <FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…\n$ memory     <list> [<Rprofmem[1559 x 3]>]\n$ time       <list> 18.9s\n$ gc         <list> [<tbl_df[1 x 3]>]\n```\n\n\n:::\n:::\n\n{{< pagebreak >}}\n\n\n\n\n\n\n\n## Session Information \n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n**R version 4.4.1 (2024-06-14 ucrt)**\n\n**Platform:** x86_64-w64-mingw32/x64 \n\n**locale:**\n_LC_COLLATE=English_United States.utf8_, _LC_CTYPE=English_United States.utf8_, _LC_MONETARY=English_United States.utf8_, _LC_NUMERIC=C_ and _LC_TIME=English_United States.utf8_\n\n**attached base packages:** \n_stats_, _graphics_, _grDevices_, _utils_, _datasets_, _methods_ and _base_\n\n**other attached packages:** \n_cli(v.3.6.3)_, _rlang(v.1.1.4)_, _fuimus(v.0.0.2)_, _lubridate(v.1.9.3)_, _forcats(v.1.0.0)_, _stringr(v.1.5.1)_, _dplyr(v.1.1.4)_, _purrr(v.1.0.2)_, _readr(v.2.1.5)_, _tidyr(v.1.3.1)_, _tibble(v.3.2.1)_, _ggplot2(v.3.5.1)_ and _tidyverse(v.2.0.0)_\n\n**loaded via a namespace (and not attached):** \n_utf8(v.1.2.4)_, _generics(v.0.1.3)_, _stringi(v.1.8.4)_, _hms(v.1.1.3)_, _digest(v.0.6.37)_, _magrittr(v.2.0.3)_, _evaluate(v.1.0.1)_, _grid(v.4.4.1)_, _timechange(v.0.3.0)_, _fastmap(v.1.2.0)_, _jsonlite(v.1.8.9)_, _bench(v.1.1.3)_, _pander(v.0.6.5)_, _kit(v.0.0.19)_, _fansi(v.1.0.6)_, _scales(v.1.3.0)_, _textshaping(v.0.4.0)_, _munsell(v.0.5.1)_, _withr(v.3.0.2)_, _yaml(v.2.3.10)_, _parallel(v.4.4.1)_, _tools(v.4.4.1)_, _tzdb(v.0.4.0)_, _colorspace(v.2.1-1)_, _profmem(v.0.6.0)_, _vctrs(v.0.6.5)_, _R6(v.2.5.1)_, _lifecycle(v.1.0.4)_, _cheapr(v.0.9.91)_, _stringfish(v.0.16.0)_, _htmlwidgets(v.1.6.4)_, _ragg(v.1.3.3)_, _pkgconfig(v.2.0.3)_, _RcppParallel(v.5.1.9)_, _pillar(v.1.9.0)_, _gtable(v.0.3.6)_, _data.table(v.1.16.99)_, _glue(v.1.8.0)_, _codex(v.0.0.0.9000)_, _Rcpp(v.1.0.13)_, _collapse(v.2.0.17)_, _systemfonts(v.1.1.0)_, _xfun(v.0.49)_, _tidyselect(v.1.2.1)_, _rstudioapi(v.0.17.1)_, _knitr(v.1.49)_, _htmltools(v.0.5.8.1)_, _rmarkdown(v.2.29)_ and _compiler(v.4.4.1)_\n:::\n:::\n",
    "supporting": [
      "npi_constructor_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}