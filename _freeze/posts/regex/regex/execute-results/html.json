{
  "hash": "2ed7d6fb2947848f62513de2cc5c1624",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Learning to Love Regexes By Learning Them\"\nsubtitle: \"I Promised Myself I Wouldn't Do This Again\"\ndescription: \"Building a regex generator for self-contained, well-defined string detection problems is a very effective way to learn regular expressions.\"\nformat:\n  html:\n    reference-location: margin\n    other-links:\n      - text: Regex Cheatsheet\n        icon: bookmark-plus\n        href: https://github.com/raredd/regex\n      - text: RexEgg\n        icon: bookmark-plus\n        href: https://www.rexegg.com/\n      - text: Regex in R\n        icon: bookmark-plus\n        href: https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Notes on HCPCS\n\n   - 5 characters\n   - Start: 1 of `c(\"ABCEGHJKLMPQRSTUV0123456789\")`\n   - Then:  3 of `c(\"0123456789\")`\n   - End:   1 of `c(\"AFMTU0123456789\")`\n   - Regex: `(^[A-CEGHJ-MP-V0-9][0-9]{3}[AFMTU0-9]$)`\n\n### HCPCS Level I (CPT)\n\n   - Start: 4 of `c(\"0123456789\")`\n   - End:   1 of `c(\"AFMTU0123456789\")`\n   - Regex: `(^[A-CEGHJ-MP-V0-9][0-9]{3}[AFMTU0-9]$)`\n   \n#### CPT Category I\n\n   - Start: 4 of `c(\"0123456789\")`\n   - End:   1 of `c(\"AFMTU0123456789\")`\n   - Regex: `(^[A-CEGHJ-MP-V0-9][0-9]{3}[AMU0-9]$)`\n\n#### CPT Category II\n\n   - Start: 4 of `c(\"0123456789\")`\n   - End:   1 of `c(\"F\")`\n   - Regex: `(^[0-9]{4}F$)`\n\n#### CPT Category III\n\n   - Start: 4 of `c(\"0123456789\")`\n   - End:   1 of `c(\"T\")`\n   - Regex: `(^[0-9]{4}T$)`\n\n### HCPCS Level II\n\n   - Start: 1 of `c(\"ABCEGHJKLMPQRSTUV\")`\n   - End:   4 of `c(\"0123456789\")`\n   - Regex: `(^[A-CEGHJ-MP-V][0-9]{3}[0-9]$)`\n\n# Building the Function\n\n   - Preprocessing\n   - Initial Split\n   - Remove Redundancies\n\n**TODO:** If a *wildcard* (`nchar(hcpcs) < 5`) begins with a *letter* (`\"C7501*\"`), the *postfix* should be **`[0-9]{n}`**, not `[0-9A-Z]{n}`.\n\n## Preprocessing\n\n::: {.panel-tabset}\n\n## 1. `split_lengths()`\n\n   - Check is character vector. \n   - Remove wildcards, white space, `NA`s and duplicates.\n   - Split into groups by lengths.\n   - Prefix names with an \"x\".\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsplit_lengths <- function(x) {\n  \n  stopifnot(is.character(x))\n  \n  x <- stringfish::sf_convert(\n    stringfish::sf_gsub(x, \"\\\\*|\\\\s\", \"\", nthreads = 4L) |> \n      fuimus::uniq_rmna() |> \n    stringr::str_sort())\n  \n  len <- collapse::vlengths(x)\n  \n  list(\n    x1 = x[len == 1],\n    x2 = x[len == 2],\n    x3 = x[len == 3],\n    x4 = x[len == 4],\n    x5 = x[len == 5]\n  )\n}\n```\n:::\n\n\n\n\n## 2. `remove_redundant()`\n\nIf a vector contains both `\"A\"` and `\"A0\"`, remove `\"A0\"`. Why? A user may input complete and incomplete HCPCS codes alongside each other. Codes that contain a common sub-string can be simplified, in turn simplifying the eventual regex output.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfish <- \\(x, i) stringfish::sf_substr(x, start = i, stop = i, nthreads = 4L)\n\n`%notin%` <- data.table::`%notin%`\n\nrc <- \\(x) if (vctrs::vec_is_empty(x)) return(character(0))\n\nrr <- \\(x, y, n = 1) {\n  \n  rc(x)\n  \n  x <- x[stringfish::sf_substr(x, 1, n, nthreads = 4L) %notin% y]\n  \n  rc(x)\n  \n  x\n}\n\nremove_redundant <- \\(x) {\n\n  c(x1, x2, x3, x4, x5) %<-% x\n  \n  list(\n    x1 = x1,\n    x2 = rr(x2, x1),\n    x3 = rr(x3, x1) |> rr(x2, 2),\n    x4 = rr(x4, x1) |> rr(x2, 2) |> rr(x3, 3),\n    x5 = rr(x5, x1) |> rr(x2, 2) |> rr(x3, 3) |> rr(x4, 4)\n  )\n  \n}\n\nhcpcs_tests[7:30] |>\n  split_lengths() |> \n  remove_redundant()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x1\ncharacter(0)\n\n$x2\n[1] \"30\" \"31\" \"32\"\n\n$x3\n[1] \"721\" \"722\" \"723\" \"724\" \"725\" \"726\" \"727\" \"728\" \"729\"\n\n$x4\n[1] \"5202\" \"5203\" \"5204\" \"5205\" \"5206\" \"5207\" \"5208\"\n\n$x5\n[1] \"92015\" \"92016\" \"92017\" \"92018\" \"92019\"\n```\n\n\n:::\n\n```{.r .cell-code}\nall_tests |>\n  split_lengths() |> \n  remove_redundant()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x1\n[1] \"0\" \"4\" \"5\" \"6\" \"G\" \"J\"\n\n$x2\n [1] \"15\" \"20\" \"22\" \"27\" \"30\" \"31\" \"32\" \"34\" \"35\" \"36\" \"76\" \"92\" \"95\" \"C7\" \"C9\"\n[16] \"E0\" \"S2\"\n\n$x3\n[1] \"721\" \"722\" \"723\" \"724\" \"725\" \"726\" \"727\" \"728\" \"729\"\n\n$x4\ncharacter(0)\n\n$x5\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n# Grouping Vectors\n\nGroups each set of vectors into groupable regex patterns.\n\n::: {.panel-tabset}\n\n## g1\n\n**TODO:** Eliminate this step.\n\nThe only thing to be done here is check that the vector is not empty.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng1 <- function(x) {\n  \n  if (vctrs::vec_is_empty(x[[\"x1\"]])) return(character(0))\n  \n  x[[\"x1\"]]\n\n}\n\nhcpcs_tests[7:30] |>\n  split_lengths() |> \n  remove_redundant() |> \n  g1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nall_tests |> \n  split_lengths() |> \n  remove_redundant() |> \n  g1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0\" \"4\" \"5\" \"6\" \"G\" \"J\"\n```\n\n\n:::\n:::\n\n\n\n\n## g2\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng2 <- function(x) {\n  \n  if (vctrs::vec_is_empty(x[[\"x2\"]])) return(character(0))\n  \n  collapse::rsplit(x[[\"x2\"]], fish(x[[\"x2\"]], 1), use.names = FALSE)\n  \n}\n\nlong_test2 |> \n  split_lengths() |> \n  remove_redundant() |>\n  g2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nall_tests |> \n  split_lengths() |> \n  remove_redundant() |> \n  g2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"15\"\n\n[[2]]\n[1] \"20\" \"22\" \"27\"\n\n[[3]]\n[1] \"30\" \"31\" \"32\" \"34\" \"35\" \"36\"\n\n[[4]]\n[1] \"76\"\n\n[[5]]\n[1] \"92\" \"95\"\n\n[[6]]\n[1] \"C7\" \"C9\"\n\n[[7]]\n[1] \"E0\"\n\n[[8]]\n[1] \"S2\"\n```\n\n\n:::\n:::\n\n\n\n\n## g3\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng3 <- function(x) {\n  \n  if (vctrs::vec_is_empty(x[[\"x3\"]])) return(character(0))\n  \n  indices <- dplyr::tibble(\n    code = x[[\"x3\"]],\n    a1 = fish(code, 1),\n    a2 = fish(code, 2),\n    a3 = fish(code, 3)) |> \n    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> \n    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> \n    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> \n    collapse::fcount(i1, add = TRUE, name = \"G\")\n\n  orphans <- indices[(indices$i2 + indices$i3 + indices$G == 3), ]$code\n    \n  last <- collapse::fcount(indices[(!indices$code %in% orphans), ], a1, a2) |> \n    dplyr::left_join(collapse::funique(indices[(!indices$code %in% orphans), ][c(\"a1\", \"G\")]), by = dplyr::join_by(a1)) |> \n    dplyr::filter(N == G) |> \n    dplyr::right_join(indices[(!indices$code %in% orphans), ][c(\"code\", \"a1\", \"a2\")], by = dplyr::join_by(a1, a2)) |> \n    dplyr::filter(!is.na(N))\n\n  rest <- indices[(!indices$code %in% c(orphans, last$code)), ]\n\n  out <- vctrs::vec_c(\n    if (vctrs::vec_is_empty(orphans)) NULL else as.list(orphans),\n    if (vctrs::vec_is_empty(last)) NULL else vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$a1)),\n    if (vctrs::vec_is_empty(rest)) NULL else vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$a1))\n  )\n  \n  if (vctrs::vec_is_empty(out)) {\n    return(character(0))\n  }\n  return(out)\n}\n\nlong_test2 |> \n  split_lengths() |> \n  remove_redundant() |> \n  g3()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\n## g4\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng4 <- function(x) {\n  \n  if (vctrs::vec_is_empty(x[[\"x4\"]])) return(character(0))\n  \n  indices <- dplyr::tibble(\n    code = x[[\"x4\"]],\n    a1 = fish(code, 1),\n    a2 = fish(code, 2),\n    a3 = fish(code, 3),\n    a4 = fish(code, 4)) |> \n    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> \n    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> \n    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> \n    dplyr::mutate(i4 = dplyr::consecutive_id(a4), .by = c(a1, a2, a3)) |> \n    collapse::fcount(i1, add = TRUE, name = \"G\")\n  \n  orphans <- indices[(indices$i2 + indices$i3 + indices$i4 + indices$G == 4), ]$code\n    \n  last <- fuimus::combine(indices[(!indices$code %in% orphans), c(1:5)], group_id, columns = c(\"a1\", \"a2\"), sep = \"\")\n    \n  last <- collapse::fcount(last, group_id, a3) |> \n    dplyr::left_join(collapse::fcount(last, group_id, name = \"G\"), by = dplyr::join_by(group_id)) |> \n    dplyr::filter(N == G) |> \n    dplyr::right_join(last, by = dplyr::join_by(group_id, a3)) |> \n    dplyr::filter(!is.na(N))\n\n  rest <- indices[(!indices$code %in% c(orphans, last$code)), ] |> fuimus::combine(group_id, columns = c(\"a1\", \"a2\", \"a3\"), sep = \"\")\n\n  out <- vctrs::vec_c(\n    if (vctrs::vec_is_empty(orphans)) NULL else as.list(orphans),\n    if (vctrs::vec_is_empty(last)) NULL else vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$group_id)),\n    if (vctrs::vec_is_empty(rest)) NULL else vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$group_id))\n  )\n  \n  if (vctrs::vec_is_empty(out)) {\n    return(character(0))\n  }\n  return(out)\n}\n\nhcpcs_tests[20:25] |> \n  split_lengths() |> \n  remove_redundant() |> \n  g4()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"5203\" \"5204\" \"5205\" \"5206\" \"5207\" \"5208\"\n```\n\n\n:::\n:::\n\n\n\n\n## g5\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ng5 <- function(x) {\n  \n  if (vctrs::vec_is_empty(x[[\"x5\"]])) return(character(0))\n  \n  indices <- dplyr::tibble(\n    code = x[[\"x5\"]],\n    a1 = fish(code, 1),\n    a2 = fish(code, 2),\n    a3 = fish(code, 3),\n    a4 = fish(code, 4),\n    a5 = fish(code, 5)) |> \n    dplyr::mutate(i1 = dplyr::consecutive_id(a1)) |> \n    dplyr::mutate(i2 = dplyr::consecutive_id(a2), .by = a1) |> \n    dplyr::mutate(i3 = dplyr::consecutive_id(a3), .by = c(a1, a2)) |> \n    dplyr::mutate(i4 = dplyr::consecutive_id(a4), .by = c(a1, a2, a3)) |> \n    dplyr::mutate(i5 = dplyr::consecutive_id(a5), .by = c(a1, a2, a3, a4)) |>\n    collapse::fcount(i1, add = TRUE, name = \"G\")\n  \n  orphans <- indices[(indices$i2 + indices$i3 + indices$i4 + indices$i5 + indices$G == 5), ]$code\n  \n  last <- fuimus::combine(\n    indices[(!indices$code %in% orphans), c(1:4, 6)], \n    group_id, columns = c(\"a1\", \"a2\", \"a3\"), sep = \"\")\n  \n  last <- collapse::fcount(last, group_id, a5) |> \n    dplyr::left_join(collapse::fcount(last, group_id, name = \"G\"), by = dplyr::join_by(group_id)) |> \n    dplyr::filter(N == G) |> \n    dplyr::right_join(last, by = dplyr::join_by(group_id, a5)) |> \n    dplyr::filter(!is.na(N))\n\n  rest <- indices[(!indices$code %in% c(orphans, last$code)), ] |> fuimus::combine(group_id, columns = c(\"a1\", \"a2\", \"a3\", \"a4\"), sep = \"\")\n\n  out <- vctrs::vec_c(\n    if (vctrs::vec_is_empty(orphans)) NULL else as.list(orphans),\n    if (vctrs::vec_is_empty(last)) NULL else vctrs::vec_chop(last$code, sizes = vctrs::vec_run_sizes(last$group_id)),\n    if (vctrs::vec_is_empty(rest)) NULL else vctrs::vec_chop(rest$code, sizes = vctrs::vec_run_sizes(rest$group_id))\n  )\n  \n  if (vctrs::vec_is_empty(out)) {\n    return(character(0))\n  }\n  return(out)\n}\n\nhcpcs_tests[26:30] |> \n  split_lengths() |> \n  remove_redundant() |> \n  g5()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"92015\" \"92016\" \"92017\" \"92018\" \"92019\"\n```\n\n\n:::\n:::\n\n\n\n\n::: \n\n### Process Groups\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprocess_groups <- function(x) {\n  \n  g <- x |> \n    split_lengths() |> \n    remove_redundant()\n  \n  list(\n    g1 = g1(g),\n    g2 = g2(g),\n    g3 = g3(g),\n    g4 = g4(g),\n    g5 = g5(g)\n  )\n}\n\ngroups <- process_groups(long_test2)\n\ngroups\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$g1\n [1] \"0\" \"1\" \"2\" \"3\" \"5\" \"6\" \"7\" \"9\" \"C\" \"E\" \"G\" \"S\"\n\n$g2\ncharacter(0)\n\n$g3\ncharacter(0)\n\n$g4\ncharacter(0)\n\n$g5\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\n# Orphans\n\n::: {.panel-tabset}\n\n## `get_orphans()`\n\n**TODO:** This needs to be done by group as opposed to lumping all orphan character lengths together, so as to create a more human-readable regex output.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npull_orphs <- function(x) {\n  \n  if (vctrs::vec_is_empty(x)) return(character(0))\n  \n  x[collapse::whichv(collapse::vlengths(x), 1)] |> purrr::list_c()\n\n}\n\npull_fams <- function(x) {\n  \n  if (vctrs::vec_is_empty(x)) return(character(0))\n  \n  x[collapse::whichv(collapse::vlengths(x), 1, TRUE)]\n\n}\n\nget_orphans <- function(x) {\n  list(\n    o2 = pull_orphs(x$g2),\n    o3 = pull_orphs(x$g3),\n    o4 = pull_orphs(x$g4),\n    o5 = pull_orphs(x$g5))\n}\n\nget_families <- function(x) {\n  list(\n    f1 = x$g1,\n    f2 = pull_fams(x$g2),\n    f3 = pull_fams(x$g3),\n    f4 = pull_fams(x$g4),\n    f5 = pull_fams(x$g5))\n}\n\norphans  <- get_orphans(groups)\n\nfamilies <- get_families(groups)\n\norphans\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$o2\ncharacter(0)\n\n$o3\ncharacter(0)\n\n$o4\ncharacter(0)\n\n$o5\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nfamilies\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$f1\n [1] \"0\" \"1\" \"2\" \"3\" \"5\" \"6\" \"7\" \"9\" \"C\" \"E\" \"G\" \"S\"\n\n$f2\ncharacter(0)\n\n$f3\ncharacter(0)\n\n$f4\ncharacter(0)\n\n$f5\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\n## Process Orphans\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvectoregex <- function(x, n) {\n  \n  if (vctrs::vec_is_empty(x)) return(NULL)\n  \n  if (is.null(n)) {\n    as.character(glue::glue_collapse(glue::glue('(^{x}$)', x = x), sep = \"|\"))\n    } else {\n      as.character(glue::glue_collapse(glue::glue('(^<<x>>[0-9A-Z]{<<n>>}$)', x = x, n = n, .open = \"<<\", .close = \">>\"), sep = \"|\"))\n    }\n}\n\nprocess_orphans <- function(x) {\n  \n  list(\n    o2 = vectoregex(x$o2, 3),\n    o3 = vectoregex(x$o3, 2),\n    o4 = vectoregex(x$o4, 1),\n    o5 = vectoregex(x$o5, NULL)) # |> \n    #purrr::compact()\n  \n  # as.character(glue::glue_collapse(orph, sep = \"|\"))\n\n}\n\norphan_regex <- process_orphans(orphans)\n\norphan_regex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$o2\nNULL\n\n$o3\nNULL\n\n$o4\nNULL\n\n$o5\nNULL\n```\n\n\n:::\n:::\n\n\n\n\n### Test Orphans Regex\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhcpcs_codes <- collapse::funique(\n  northstar::search_descriptions()$hcpcs_code)\n\ntest_orphans <- vctrs::vec_slice(\n  hcpcs_codes, \n  stringfish::sf_grepl(\n    hcpcs_codes, \n    orphan_regex\n    )\n  )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in stringfish::sf_grepl(hcpcs_codes, orphan_regex): STRING_ELT() can only be applied to a 'character vector', not a 'list'\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(hcpcs_codes)  # 18903\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18903\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(test_orphans) # 1521\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'test_orphans' not found\n```\n\n\n:::\n:::\n\n\n\n\n::: \n\n## Process Families\n\n### Separate Characters & Numbers\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nget_char <- \\(x) x[stringfish::sf_grepl(x, \"[A-Z]\", nthreads = 4L)]\nget_numb <- \\(x) x[stringfish::sf_grepl(x, \"[0-9]\", nthreads = 4L)]\n\nget_char(c(LETTERS, 0:9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n\n\n:::\n\n```{.r .cell-code}\nget_numb(c(LETTERS, 0:9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\"\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npull_char <- \\(x) stringr::str_extract_all(x, stringr::regex(\"[A-Z]\"))\npull_numb <- \\(x) stringr::str_extract_all(x, stringr::regex(\"[0-9]\"))\n\n# pull_char(c(LETTERS, 0:9))\n# pull_numb(c(LETTERS, 0:9))\n```\n:::\n\n\n\n\n### Sort & Order\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsort_order <- function(x) {\n  \n  sorted   <- stringr::str_sort(x, numeric = TRUE)\n  alphabet <- purrr::list_c(pull_char(sorted))\n  numbers  <- purrr::list_c(pull_numb(sorted))\n  \n  paste0(fuimus::collapser(alphabet), fuimus::collapser(numbers))\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsort_order2 <- function(x) {\n  \n  sorted   <- stringr::str_sort(x, numeric = TRUE)\n  alphabet <- get_char(sorted)\n  numbers  <- get_numb(sorted)\n  \n  paste0(fuimus::collapser(alphabet), fuimus::collapser(numbers))\n}\n```\n:::\n\n\n\n\n### Reduce Runs\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreduce_runs <- function(x) {\n  \n  vec  <- rlang::set_names(rep(0, 36), c(LETTERS, 0:9))\n  vec2 <- vec[fuimus::splitter(x)]\n  vec2 <- vec2[!is.na(vec2)]\n  vec[names(vec2)] <- 1\n\n  vec_group <- dplyr::tibble(\n    value = names(vec),\n    key = vec,\n    idx = seq_along(vec),\n    group = dplyr::consecutive_id(key)) |>\n    dplyr::mutate(group_size = dplyr::n(),\n                  .by = group) |>\n    dplyr::filter(key == 1, group_size >= 3) |>\n    dplyr::select(value, group)\n\n  if (vctrs::vec_is_empty(vec_group)) return(x)\n\n  xgroups <- unname(split(vec_group, vec_group$group)) |>\n    purrr::map(purrr::pluck(\"value\")) |>\n    purrr::map(fuimus::collapser) |>\n    purrr::list_c()\n\n  replacements <- dplyr::left_join(\n    dplyr::slice_min(vec_group, by = group, order_by = value) |> dplyr::rename(start = value),\n    dplyr::slice_max(vec_group, by = group, order_by = value) |> dplyr::rename(end = value),\n    by = dplyr::join_by(group)) |>\n    glue::glue_data(\"{start}-{end}\") |>\n    as.vector()\n\n  res <- stringi::stri_replace_all_regex(x, xgroups, replacements, vectorize_all = FALSE)\n\n  paste0(\"[\", res, \"]\")\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nreduce_runs2 <- function(x) {\n  \n  test <- list(\n    char = purrr::map(x, pull_char) |> purrr::list_c() |> purrr::compact() |> purrr::list_c(),\n    numb = purrr::map(x, pull_numb) |> purrr::list_c() |> purrr::compact() |> purrr::list_c())\n  \n  vec <- list(\n    char = rlang::set_names(rep(0, 26), LETTERS),\n    numb = rlang::set_names(rep(0, 10), as.character(0:9)))\n  \n  vna <- list(\n    char = vec$char[test$char],\n    numb = vec$numb[test$numb])\n  \n  vna <- list(\n    char = vna$char[!is.na(vna$char)],\n    numb = vna$numb[!is.na(vna$numb)])\n  \n  vec$char[names(vna$char)] <- 1\n  vec$numb[names(vna$numb)] <- 1\n  \n  group_char <- dplyr::tibble(\n    value = names(vec$char),\n    key = vec$char,\n    idx = seq_along(vec$char),\n    group = dplyr::consecutive_id(key)) |>\n    dplyr::mutate(group_size = dplyr::n(), .by = group) |>\n    dplyr::filter(key == 1, group_size >= 3) |>\n    dplyr::select(value, group)\n  \n  group_numb <- dplyr::tibble(\n    value = names(vec$numb),\n    key = vec$numb,\n    idx = seq_along(vec$numb),\n    group = dplyr::consecutive_id(key)) |>\n    dplyr::mutate(group_size = dplyr::n(), .by = group) |>\n    dplyr::filter(key == 1, group_size >= 3) |>\n    dplyr::select(value, group)\n  \n  xgroups_char <- unname(split(group_char, group_char$group)) |>\n    purrr::map(purrr::pluck(\"value\")) |>\n    purrr::map(paste0, collapse = \"\") |>\n    purrr::list_c()\n  \n  xgroups_numb <- unname(split(group_numb, group_numb$group)) |>\n    purrr::map(purrr::pluck(\"value\")) |>\n    purrr::map(paste0, collapse = \"\") |>\n    purrr::list_c()\n  \n  replace_char <- dplyr::left_join(\n    dplyr::slice_min(group_char, by = group, order_by = value) |> dplyr::rename(start = value),\n    dplyr::slice_max(group_char, by = group, order_by = value) |> dplyr::rename(end = value),\n    by = dplyr::join_by(group)) |>\n    glue::glue_data(\"{start}-{end}\") |>\n    as.vector()\n  \n  replace_numb <- dplyr::left_join(\n    dplyr::slice_min(group_numb, by = group, order_by = value) |> dplyr::rename(start = value),\n    dplyr::slice_max(group_numb, by = group, order_by = value) |> dplyr::rename(end = value),\n    by = dplyr::join_by(group)) |>\n    glue::glue_data(\"{start}-{end}\") |>\n    as.vector()\n  \n  orig <- list(\n    char = fuimus::collapser(test$char),\n    numb = fuimus::collapser(test$numb))\n  \n  res <- list(\n    char = if(!vctrs::vec_is_empty(group_char)) {\n      stringi::stri_replace_all_regex(\n        orig$char, \n        xgroups_char, \n        replace_char, \n        vectorize_all = FALSE)\n      } else {\n        orig$char\n        },\n    numb = if(!vctrs::vec_is_empty(group_numb)) {\n      stringi::stri_replace_all_regex(\n        orig$numb, \n        xgroups_numb, \n        replace_numb, \n        vectorize_all = FALSE)\n    } else {\n        orig$numb\n      }\n    )\n  paste0(\"[\", res$char, res$numb, \"]\")\n}\n```\n:::\n\n\n\n\n\n### Groups == 1\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprocess_hcpcs_1 <- function(x) {\n  \n  if (!rlang::has_name(x, \"f1\")) return(NULL)\n  \n  re <- sort_order(x[[\"f1\"]]) |> \n    reduce_runs2()\n  \n  if (re == \"[A-Z0-9]\") {\n    \n    return(stringr::str_glue(\"(^{re}{{5}}$)\"))\n    \n  } else {\n    \n    return(stringr::str_glue(\"(^{re}[A-Z0-9]{{4}}$)\"))\n    \n    }\n}\n\nprocess_hcpcs_1(families)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(^[CEGS0-35-79][A-Z0-9]{4}$)\n```\n\n\n:::\n:::\n\n\n\n\n### Groups > 1\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprocess_hcpcs_2 <- function(x) {\n  \n  if (is.null(x)) return(NULL)\n  \n  vecs <- stringr::str_split_fixed(\n    x, \n    \"\", \n    n = collapse::fmax(\n      collapse::vlengths(x)\n      )\n    ) |>\n    as.data.frame()\n  \n  to_brackets <- vecs |>\n    purrr::map(fuimus::uniq_rmna) |>\n    purrr::map(sort_order)\n  \n  to_vec <- to_brackets |>\n    purrr::map(reduce_runs)\n  \n  multi_chars <- unname(nchar(to_vec) > 1)\n  \n  nobrack <- stringr::str_detect(to_vec[multi_chars], \"\\\\[|\\\\]\", TRUE)\n\n  to_vec[multi_chars] <- if (any(nobrack)) purrr::map_chr(to_vec[multi_chars], \\(x) paste0(\"[\", x, \"]\")) else to_vec[multi_chars]\n\n  to_vec <- purrr::list_c(to_vec)\n\n  fuimus::collapser(to_vec)\n}\n\npurrr::map_chr(families$f5, process_hcpcs_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n\n\n### Process Families\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprocess_families <- function(x) {\n  \n  x <- list(\n    f1 = process_hcpcs_1(families),\n    f2 = purrr::map_chr(families$f2, process_hcpcs_2),\n    f3 = purrr::map_chr(families$f3, process_hcpcs_2),\n    f4 = purrr::map_chr(families$f4, process_hcpcs_2),\n    f5 = purrr::map_chr(families$f5, process_hcpcs_2)\n  )\n  \n  fam <- list(\n    f1 = x$f1,\n    f2 = vectoregex(x$x2, 3),\n    f3 = vectoregex(x$f3, 2),\n    f4 = vectoregex(x$f4, 1),\n    f5 = vectoregex(x$f5, NULL)\n  ) |> \n    purrr::compact()\n  \n  glue::glue_collapse(fam, sep = \"|\")\n}\n\nfamilies_regex <- process_families(families)\n\nfamilies_regex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(^[CEGS0-35-79][A-Z0-9]{4}$)\n```\n\n\n:::\n:::\n\n\n\n\n### Test Families Regex\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_families <- vctrs::vec_slice(\n  hcpcs_codes, \n  stringfish::sf_grepl(\n    hcpcs_codes, \n    families_regex\n    )\n  )\n\nlength(hcpcs_codes)   # 18903\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18903\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(test_families) # 11900\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11900\n```\n\n\n:::\n:::\n\n\n\n\n## Concatenate Regex\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconcatenate_regex <- function(x, y) {\n  as.character(glue::glue_collapse(c(x, y), sep = \"|\"))\n}\n\nwhole_regex <- concatenate_regex(families_regex, orphan_regex)\n```\n:::\n\n\n\n\n### Test Whole Regex\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_whole <- vctrs::vec_slice(\n  hcpcs_codes, \n  stringfish::sf_grepl(\n    hcpcs_codes, \n    whole_regex\n    )\n  )\n\nlength(hcpcs_codes) # 18903\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18903\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(test_whole)  # 11900\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11900\n```\n\n\n:::\n:::\n\n{{< pagebreak >}}\n\n\n\n\n\n\n::: {#nte-references .callout-tip collapse=\"true\"}\n\n## Links\n\n### Reference\n\n   - [Regex Cheatsheet](https://github.com/raredd/regex)\n   - [Learn Regex](https://github.com/ziishaned/learn-regex)\n   - [Evaluating strings as code](https://josiahparry.com/posts/2024-06-13-eval-strings)\n   - [Building rules from code operands](https://github.com/Permian-Global-Research/rsi)\n   - [Filter logic](https://github.com/atorus-research/ardis/blob/main/R/denom.R)\n   - [Regular-Expression.info](https://www.regular-expressions.info/tutorial.html)\n   - [RexEgg](https://www.rexegg.com/)\n   - [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html)\n   - [Debuggex](https://www.debuggex.com/)\n\n### Packages\n\n   - [**textshape**](https://github.com/trinker/textshape)\n   - [**stringr.plus**](https://github.com/johncassil/stringr.plus)\n   - [**regexmagic**](https://github.com/jonocarroll/regexmagic)\n   - [**makeunique**](https://github.com/selkamand/makeunique)\n   - [**similiars**](https://github.com/davidsjoberg/similiars)\n   - [**strex**](https://github.com/rorynolan/strex/)\n   - [**stringfish**](https://github.com/traversc/stringfish)\n   - [**collapse**](https://sebkrantz.github.io/collapse/)\n   - [**kit**](https://github.com/2005m/kit)\n   - [**cheapr**](https://github.com/NicChr/cheapr)\n   - [**fastplyr**](https://github.com/NicChr/fastplyr)\n   - [**stringi**](https://stringi.gagolewski.com/)\n   - [**qdapRegex**](https://github.com/trinker/qdapRegex)\n   - [**charcuterie**](https://github.com/jonocarroll/charcuterie)\n\n### Functions\n\n   - [mark::globbing](https://github.com/jmbarbone/mark/blob/main/R/glob.R)\n   - [RUtil::make_unique_comb](https://github.com/raivokolde/RUtil/blob/master/Source/R/make_unique_comb.r)\n   - [mirmisc::longest_common_substring](https://github.com/mirvie/mirmisc/blob/main/R/utils.R)\n   - [hutils::longest prefix/suffix](https://github.com/HughParsonage/hutils/blob/master/R/longest_affix.R)\n   - [tidyext::combn_2_col](https://github.com/m-clark/tidyext/blob/master/R/combn_2_col.R)\n\n::: \n\n\n# Session Information\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n═ Session info ═══════════════════════════════════════════════════════════════\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package       * version date (UTC) lib source\n   cheapr        * 0.9.9   2024-10-14 [1] RSPM (R 4.4.0)\n   cli           * 3.6.3   2024-06-21 [1] RSPM (R 4.4.0)\n   collapse      * 2.0.16  2024-08-21 [1] RSPM (R 4.4.0)\n   colorspace      2.1-1   2024-07-26 [1] RSPM (R 4.4.0)\n   crayon          1.5.3   2024-06-20 [1] RSPM (R 4.4.0)\n   data.table      1.16.2  2024-10-10 [1] RSPM (R 4.4.0)\n   digest          0.6.37  2024-08-19 [1] RSPM (R 4.4.0)\n   dplyr         * 1.1.4   2023-11-17 [1] RSPM (R 4.4.0)\n   evaluate        1.0.1   2024-10-10 [1] RSPM (R 4.4.0)\n   fansi           1.0.6   2023-12-08 [1] RSPM (R 4.4.0)\n   fastmap         1.2.0   2024-05-15 [1] RSPM (R 4.4.0)\n   fastplyr      * 0.2.0   2024-10-04 [1] RSPM (R 4.4.0)\n   forcats       * 1.0.0   2023-01-29 [1] RSPM (R 4.4.0)\n   fs              1.6.4   2024-04-25 [1] RSPM (R 4.4.0)\n   fuimus          0.0.2   2024-10-15 [1] local\n   generics        0.1.3   2022-07-05 [1] RSPM (R 4.4.0)\n   ggplot2       * 3.5.1   2024-04-23 [1] RSPM (R 4.4.0)\n   glue            1.8.0   2024-09-30 [1] RSPM (R 4.4.0)\n   gtable          0.3.5   2024-04-22 [1] RSPM (R 4.4.0)\n   hms             1.1.3   2023-03-21 [1] RSPM (R 4.4.0)\n   htmltools       0.5.8.1 2024-04-04 [1] RSPM (R 4.4.0)\n   htmlwidgets     1.6.4   2023-12-06 [1] RSPM (R 4.4.0)\n   jsonlite        1.8.9   2024-09-20 [1] RSPM (R 4.4.0)\n   knitr           1.48    2024-07-07 [1] CRAN (R 4.4.1)\n   lifecycle       1.0.4   2023-11-07 [1] RSPM (R 4.4.0)\n   lubridate     * 1.9.3   2023-09-27 [1] RSPM (R 4.4.0)\n   magrittr        2.0.3   2022-03-30 [1] RSPM (R 4.4.0)\n   munsell         0.5.1   2024-04-01 [1] RSPM (R 4.4.0)\n   northstar       0.0.7   2024-07-30 [1] Github (andrewallenbruce/northstar@5c01119)\n   pillar          1.9.0   2023-03-22 [1] RSPM (R 4.4.0)\n   pins            1.4.0   2024-10-07 [1] RSPM (R 4.4.0)\n   pkgconfig       2.0.3   2019-09-22 [1] RSPM (R 4.4.0)\n   purrr         * 1.0.2   2023-08-10 [1] RSPM (R 4.4.0)\n   qs              0.27.2  2024-10-01 [1] RSPM (R 4.4.0)\n   R6              2.5.1   2021-08-19 [1] RSPM (R 4.4.0)\n   ragg            1.3.3   2024-09-11 [1] RSPM (R 4.4.0)\n   RApiSerialize   0.1.4   2024-09-28 [1] RSPM (R 4.4.0)\n   rappdirs        0.3.3   2021-01-31 [1] RSPM (R 4.4.0)\n   Rcpp            1.0.13  2024-07-17 [1] RSPM (R 4.4.0)\n D RcppParallel    5.1.9   2024-08-19 [1] RSPM (R 4.4.0)\n   readr         * 2.1.5   2024-01-10 [1] RSPM (R 4.4.0)\n   rlang         * 1.1.4   2024-06-04 [1] RSPM (R 4.4.0)\n   rmarkdown       2.28    2024-08-17 [1] CRAN (R 4.4.1)\n   rstudioapi      0.17.0  2024-10-16 [1] RSPM (R 4.4.0)\n   scales          1.3.0   2023-11-28 [1] RSPM (R 4.4.0)\n   sessioninfo     1.2.2   2021-12-06 [1] RSPM (R 4.4.0)\n   stringfish      0.16.0  2023-11-28 [1] RSPM (R 4.4.0)\n   stringi         1.8.4   2024-05-06 [1] RSPM (R 4.4.0)\n   stringr       * 1.5.1   2023-11-14 [1] RSPM (R 4.4.0)\n   systemfonts     1.1.0   2024-05-15 [1] RSPM (R 4.4.0)\n   textshaping     0.4.0   2024-05-24 [1] RSPM (R 4.4.0)\n   tibble        * 3.2.1   2023-03-20 [1] RSPM (R 4.4.0)\n   tidyr         * 1.3.1   2024-01-24 [1] RSPM (R 4.4.0)\n   tidyselect      1.2.1   2024-03-11 [1] RSPM (R 4.4.0)\n   tidyverse     * 2.0.0   2023-02-22 [1] RSPM (R 4.4.0)\n   timechange      0.3.0   2024-01-18 [1] RSPM (R 4.4.0)\n   tzdb            0.4.0   2023-05-12 [1] RSPM (R 4.4.0)\n   utf8            1.2.4   2023-10-22 [1] RSPM (R 4.4.0)\n   vctrs           0.6.5   2023-12-01 [1] RSPM (R 4.4.0)\n   withr           3.0.1   2024-07-31 [1] RSPM (R 4.4.0)\n   xfun            0.48    2024-10-03 [1] RSPM (R 4.4.0)\n   yaml            2.3.10  2024-07-26 [1] RSPM (R 4.4.0)\n   zeallot       * 0.1.0   2018-01-28 [1] RSPM\n\n [1] C:/Users/Andrew/AppData/Local/R/win-library/4.4\n [2] C:/Program Files/R/R-4.4.1/library\n\n D ── DLL MD5 mismatch, broken installation.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}