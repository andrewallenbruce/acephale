{
  "hash": "ce1846b942b08139921a49ee2af85946",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Metaprogramming\"\nformat:\n  html:\n    reference-location: block\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n# Advanced Operations\n\nCreate a new function call `my_mean()` that will take an argument, `x`, and then returns the results of `enquo(x)`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean <- function(x) enquo(x)\n```\n:::\n\nTest the new function. It should return the same variable name, but inside a quosure. Use `order_total` as its argument's value to test\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean(order_total)\n```\n:::\n\nRemove the last line that has `x`,  add the contents of the function with the initial `dplyr` code from step\nThen replace `order_total` with `!! x`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean <- function(x) {\n  x <- enquo(x)\n  orders |>\n    summarise(mean = mean(!!x, na.rm = TRUE))\n}\n```\n:::\n\nIn the `summarise()` step, replace the name `mean`, with `!! as_label(x)`, also replace the `=` sign, with `:=`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean <- function(x){\n  x <- enquo(x)\n  \n    summarise(\n      !!as_label(x) := mean(!!x, na.rm = TRUE))\n}\n```\n:::\n\nRun the function again, the name of the column should match the argument value\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean(order_total)\n```\n:::\n\nTest the function by passing a formula, such as `order_total / order_qty`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(order_total / order_qty)\n```\n:::\n\nMake the function generic, add a new argument called: `.data`. Inisde the function, replace `orders` with `.data`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean <- function(.data, x) {\n  x <- enquo(x)\n  .data %>%\n    summarise(!!as_label(x) := mean(!!x, na.rm = TRUE))\n}\n```\n:::\n\n1. The function now behaves more like a `dplyr` verb. Start with `orders` and then pipe into the function\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  my_mean(order_total)\n```\n:::\n\n1. Clean up the code by removing the pipe that inside the function\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_mean <- function(.data, x) {\n  x <- enquo(x)\n  summarise(.data, !!as_label(x) := mean(!!x, na.rm = TRUE))\n}\n```\n:::\n\n1. Confirm that there is no change in the behavior of the function\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  my_mean(order_total)\n```\n:::\n\n1. Add a `show_query()` step to preview the resulting SQL statement\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  my_mean(order_total) %>%\n  show_query()\n```\n:::\n\n1. Try the function with a non-DB backed variable, such as `mtcars`. Use `mpg` as the aggregating variable\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars %>%\n  my_mean(mpg)\n```\n:::\n\n## Multiple variables\n*Create functions that handle a variable number of arguments. The goal of the exercise is to create an `anti-select()` function.*\n\n1. Load the `purrr` package\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n1. Use *...* as the second argument of a function called `de_select()`.  Inside the function use `enquos()` to parse it\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nde_select <- function(.data, ...) {\n  vars <- enquos(...)\n  vars\n}\n```\n:::\n\n1. Test the function using *orders*\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  de_select(order_id, date)\n```\n:::\n\n1. Add a step to the function that iterates through each quosure and prefixes a minus sign to tell `select()` to drop that specific field.  Use `map()` for the iteration, and `quo()` to create the prefixed expression.\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nde_select <- function(.data, ...) {\n  vars <- enquos(...)\n  vars <- map(vars, ~ quo(-!!.x))\n  vars\n}\n```\n:::\n\n1. Run the same test to view the new results\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  de_select(order_id, date)\n```\n:::\n\n1. Add the `select()` step.  Use *!!!* to parse the *vars* variable inside `select()`\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nde_select <- function(.data, ...) {\n  vars <- enquos(...)\n  vars <- map(vars, ~ quo(-!!.x))\n  select(.data, !!!vars)\n}\n```\n:::\n\n1. Run the test again, this time the operation will take place.  \n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  de_select(order_id, date)\n```\n:::\n\n1. Add a `show_query()` step to see the resulting SQL\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  de_select(order_id, date) %>%\n  show_query()\n```\n:::\n\n1. Test the function with a different data set, such as `mtcars`\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars %>%\n  de_select(mpg, wt, am)\n```\n:::\n\n## Multiple queries\n*Suggested approach to avoid passing multiple, and similar, queries to the database*\n\n1. Create a simple `dplyr` piped operation that returns the mean of *order_total* for the months of January, February and March as a group\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  filter(date_month %in% c(1,2,3)) %>%\n  summarise(mean = mean(order_total, na.rm = TRUE)) \n```\n:::\n\n1. Assign the first operation to a variable called *a*, and create copy of the operation but changing the selected months to January, March and April.  Assign the second one to a variable called *b*.\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- orders %>%\n  filter(date_month %in% c(1,2,3)) %>%\n  summarise(mean = mean(order_total, na.rm = TRUE)) \n\nb <- orders %>%\n  filter(date_month %in% c(1,3,4)) %>%\n  summarise(mean = mean(order_total, na.rm = TRUE)) \n```\n:::\n\n1. Use *union()* to pass *a* and *b* at the same time to the database\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunion(a, b)\n```\n:::\n\n1. Pipe the previous instruction to `show_query()` to confirm that the resulting query is a single one\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunion(a, b) %>%\n  show_query()\n```\n:::\n\n\n1. Assign to a new variable called *months* an overlapping set of months\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonths <- list(\n  c(1,2,3),\n  c(1,3,4),\n  c(2,4,6)\n)\n```\n:::\n\n1. Use `map()` to cycle through each set of overlapping months.  Notice that it returns three separate results, meaning that it went to the database three times\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonths %>%\n  map(\n    ~ orders %>%\n        filter(date_month %in% .x) %>%\n        summarise(mean = mean(order_total, na.rm = TRUE)) \n  )\n```\n:::\n\n1. Add a `reduce()` operation and use `union()` command to create a single query\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonths %>%\n  map(\n    ~ orders %>%\n        filter(date_month %in% .x) %>%\n        summarise(mean = mean(order_total, na.rm = TRUE)) \n  ) %>%\n  reduce(function(x, y) union(x, y))\n```\n:::\n\n1. Use `show_query()` to see the resulting single query sent to the database\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonths %>%\n  map(\n    ~ orders %>%\n        filter(date_month %in% .x) %>%\n        summarise(mean = mean(order_total, na.rm = TRUE)) \n  ) %>%\n  reduce(function(x, y) union(x, y)) %>%\n  show_query()\n```\n:::\n\n\n## Multiple queries with an overlapping range\n\n1. Create a table with a *from* and *to* ranges\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nranges <- tribble(\n  ~ from, ~to, \n       1,   4,\n       2,   5,\n       3,   7\n)\n```\n:::\n\n1. See how `map2()` works by passing the two variables as the *x* and *y* arguments, and adding them as the function\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap2(ranges$from, ranges$to, ~.x + .y)\n```\n:::\n\n1. Replace *x + y* with the `dplyr` operation from the previous exercise.  In it, re-write the filter to use *x* and *y* as the month ranges \n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap2(\n  ranges$from,\n  ranges$to,\n  ~ orders %>%\n    filter(date_month >= .x & date_month <= .y) %>%\n    summarise(mean = mean(order_total, na.rm = TRUE))\n)\n```\n:::\n\n1. Add the `reduce()` operation\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap2(\n  ranges$from,\n  ranges$to,\n  ~ orders %>%\n    filter(date_month >= .x & date_month <= .y) %>%\n    summarise(mean = mean(order_total, na.rm = TRUE))\n) %>%\n  reduce(function(x, y)\n    union(x, y))\n```\n:::\n\n1. Add a `show_query()` step to see how the final query was constructed.\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmap2(\n  ranges$from,\n  ranges$to,\n  ~ orders %>%\n    filter(date_month >= .x & date_month <= .y) %>%\n    summarise(mean = mean(order_total, na.rm = TRUE))\n) %>%\n  reduce(function(x, y)\n    union(x, y)) %>%\n  show_query()\n```\n:::\n\n\n## Characters to field names\n\n1. Create two character variables. One with the name of a field in *flights* and another with a new name to be given to the field\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_field <- \"new\"\norders_field <- \"order_total\"\n```\n:::\n\n1. Add a `mutate()` step that adds the new field. And then another step selecting just the new field\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  mutate(my_field = !! orders_field) %>%\n  select(my_field)\n```\n:::\n\n1. Add a `mutate()` step that adds the new field. And then another step selecting just the new field\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  mutate(!! my_field := !! orders_field) %>%\n  select(my_field)\n```\n:::\n\n1. Wrap `orders_field` inside a `sym()` function\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders %>%\n  mutate(!! my_field := !! sym(orders_field)) %>%\n  select(my_field)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}